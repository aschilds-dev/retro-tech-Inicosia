src/bmp_parse_pixel_data.c:			env->textures[index].str[x + y * parser->w] = get_pixel(byte, str, parser); 
src/bmp_parser.c:	if (!(env->textures[index].surface = SDL_CreateRGBSurfaceWithFormat(
src/bmp_parser.c:	/*if (!(env->sdl.image_str = (Uint32*)malloc(sizeof(Uint32) * parser.w * parser.h)))
src/bmp_parser.c:	env->textures[index].str = env->textures[index].surface->pixels;
src/bmp_parser.c:	env->textures[index].scale = 1;
src/bmp_parser.c:	env->textures[index].xpadding = 0;
src/bmp_parser.c:	env->textures[index].ypadding = 0;
src/check_parsing.c:	ft_printf("{yellow}Vertex %d\n", env->nb_vertices);
src/check_parsing.c:	while (i < env->nb_vertices)
src/check_parsing.c:		ft_printf("vertex	%f %f\n", env->vertices[i].y, env->vertices[i].x);
src/check_parsing.c:	ft_printf("\nSector %d\n", env->nb_sectors);
src/check_parsing.c:	while (i < env->nb_sectors)
src/check_parsing.c:		ft_printf("sector	%f %f	", env->sectors[i].floor,
src/check_parsing.c:				env->sectors[i].ceiling);
src/check_parsing.c:		while (j < env->sectors[i].nb_vertices)
src/check_parsing.c:			ft_printf("%d ", env->sectors[i].vertices[j]);
src/check_parsing.c:		while (j < env->sectors[i].nb_vertices)
src/check_parsing.c:			ft_printf("%d ", env->sectors[i].neighbors[j]);
src/check_parsing.c:	ft_printf("\nplayer	%f %f	%f %d\n{reset}", env->player.pos.y,
src/check_parsing.c:			env->player.pos.x, env->player.angle, env->player.sector);
src/clear_image.c:	pixels = env->sdl.texture_pixels;
src/clear_image.c:	zbuffer = env->depth_array;
src/clear_image.c:	xmax = env->w;
src/clear_image.c:	ymax = env->h;
src/clear_image.c:			//env->sdl.img_str[x + y * env->w] = 0xFF;
src/clear_image.c:	while (y < env->h / 2)
src/clear_image.c:		while (x < env->w)
src/clear_image.c:			env->sdl.img_str[x + y * env->w] = 0x222222FF;
src/clear_image.c:	y = env->h / 2;
src/clear_image.c:	while (y < env->h)
src/clear_image.c:		while (x < env->w)
src/clear_image.c:			env->sdl.img_str[x + y * env->w] = 0x444444FF;
src/clear_image.c:	//SDL_UpdateTexture(env->sdl.texture, NULL, env->sdl.texture_pixels, sizeof(Uint32) * env->w);
src/clipping.c:	max = env->nb_vertices;
src/clipping.c:		env->vertices[i].clipped[0] = 0;
src/clipping.c:		env->vertices[i].clipped[1] = 0;
src/clipping.c:		env->vertices[i].clipped_x[0] = env->vertices[i].x;
src/clipping.c:		env->vertices[i].clipped_x[1] = env->vertices[i].x;
src/clipping.c:		env->vertices[i].clipped_y[0] = env->vertices[i].y;
src/clipping.c:		env->vertices[i].clipped_y[1] = env->vertices[i].y;
src/clipping.c:	while (i < env->nb_sectors)
src/clipping.c:		max = env->sectors[i].nb_vertices;
src/clipping.c:			env->sectors[i].clipped_floors1[j] = env->sectors[i].floors[j];
src/clipping.c:			env->sectors[i].clipped_ceilings1[j] = env->sectors[i].ceilings[j];
src/clipping.c:			env->sectors[i].clipped_floors2[j] = env->sectors[i].floors[j];
src/clipping.c:			env->sectors[i].clipped_ceilings2[j] = env->sectors[i].ceilings[j];
src/clipping.c:			new_v2(env->camera.near_left, env->camera.near_z),
src/clipping.c:			new_v2(env->camera.far_left, env->camera.far_z));
src/clipping.c:			new_v2(env->camera.near_right, env->camera.near_z),
src/clipping.c:			new_v2(env->camera.far_right, env->camera.far_z));
src/clipping.c:				new_v2(env->camera.near_left, env->camera.near_z),
src/clipping.c:				new_v2(env->camera.near_right, env->camera.near_z));
src/clipping.c:				new_v2(env->camera.far_left, env->camera.far_z),
src/clipping.c:				new_v2(env->camera.far_right, env->camera.far_z));
src/clipping.c:	if ((render->vz1 < env->camera.near_z && render->vz2 < env->camera.near_z)
src/clipping.c:			|| (render->vz1 > env->camera.far_z && render->vz2 > env->camera.far_z)
src/clipping.c:			|| (render->vx1 < env->camera.far_left && render->vx2 < env->camera.far_left)
src/clipping.c:			|| (render->vx2 > env->camera.far_right && render->vx2 > env->camera.far_right))
src/clipping.c:	if ((render->inter_left.x >= env->camera.far_left
src/clipping.c:			&& render->inter_left.x <= env->camera.near_left
src/clipping.c:			&& render->inter_left.y >= env->camera.near_z
src/clipping.c:			&& render->inter_left.y <= env->camera.far_z)
src/clipping.c:			|| (render->inter_right.x >= env->camera.near_right
src/clipping.c:			&& render->inter_right.x <= env->camera.far_right
src/clipping.c:			&& render->inter_right.y >= env->camera.near_z
src/clipping.c:			&& render->inter_right.y <= env->camera.far_z)
src/clipping.c:			|| (render->inter_far.x >= env->camera.far_left
src/clipping.c:			&& render->inter_far.x <= env->camera.far_right)
src/clipping.c:			|| (render->inter_near.x >= env->camera.near_left
src/clipping.c:			&& render->inter_near.x <= env->camera.near_right))
src/clipping.c:	/*if (render->vz1 >= env->camera.near_z || render->vz2 >= env->camera.near_z)
src/clipping.c:	if (render->vz1 < env->camera.near_z)
src/clipping.c:	if (render->vz2 < env->camera.near_z)
src/clipping.c:	/*if (render->vz1 <= env->camera.near_z || render->vz2 <= env->camera.near_z)
src/clipping.c:		if (render->vz1 < env->camera.near_z)
src/clipping.c:			if(render->inter_left.y > env->camera.near_z)
src/clipping.c:		if (render->vz2 < env->camera.near_z)
src/clipping.c:			if(render->inter_left.y > env->camera.near_z)
src/doom.c:	env->player.speed = 0.5;
src/doom.c:	env->player.size_2d = 0.5;
src/doom.c:	Mix_PlayMusic(env->sound.background, -1);
src/doom.c:	env->flag = 0;
src/doom.c:	while (env->running)
src/doom.c:		Mix_VolumeMusic(MIX_MAX_VOLUME/env->sound.g_music);
src/doom.c:		SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
src/doom.c:		SDL_GetMouseState(&env->sdl.mx, &env->sdl.my);
src/doom.c:		while (SDL_PollEvent(&env->sdl.event))
src/doom.c:			if (env->sdl.event.type == SDL_QUIT || (env->sdl.event.type == SDL_KEYUP && env->sdl.event.key.keysym.sym == SDLK_ESCAPE))
src/doom.c:				env->running = 0;
src/doom.c:			else if (env->sdl.event.type == SDL_KEYDOWN
src/doom.c:					|| env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONDOWN
src/doom.c:					|| env->sdl.event.type == SDL_MOUSEBUTTONUP || env->sdl.event.type == SDL_MOUSEWHEEL)
src/doom.c:		if (env->menu_start)
src/doom.c:			if (env->option)
src/draw.c:	SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
src/draw.c:	if (env->options.show_minimap)
src/draw.c:	if ((env->inputs.leftclick && !env->shot.on_going && !env->weapon_change.on_going) || env->shot.on_going)
src/draw.c:		weapon_animation(env, env->player.curr_weapon);
src/draw.c:		draw_weapon(env, env->weapons[env->player.curr_weapon].first_sprite);
src/draw.c:	if (env->weapon_change.on_going && !env->shot.on_going)
src/draw.c:	if (env->options.show_fps)
src/draw.c:	if (env->options.test)
src/draw_functions.c:	texture = env->textures[render.texture];
src/draw_functions.c:	pixels = env->sdl.texture_pixels;
src/draw_functions.c:	zbuffer = env->depth_array;
src/draw_functions.c:	if (env->options.contouring)
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.start >= 0 && vline.start <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.start >= 0 && vline.start < env->h
src/draw_functions.c:					&& render.z <= zbuffer[vline.x + env->w * vline.start])
src/draw_functions.c:				pixels[vline.x + env->w * vline.start] = 0xFF222222;
src/draw_functions.c:				zbuffer[vline.x + env->w * vline.start] = render.z;
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.end >= 0 && vline.end <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.end >= 0 && vline.end < env->h
src/draw_functions.c:					&& render.z <= zbuffer[vline.x + env->w * vline.end])
src/draw_functions.c:				pixels[vline.x + env->w * vline.end] = 0xFF222222;
src/draw_functions.c:				zbuffer[vline.x + env->w * vline.end] = render.z;
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && i >= 0 && i <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && i >= 0 && i < env->h
src/draw_functions.c:					&& render.z <= zbuffer[vline.x + env->w * i])
src/draw_functions.c:				if (!env->options.lighting)
src/draw_functions.c:					pixels[vline.x + env->w * i] = texture_pixels[(int)x + texture_w * (int)y];
src/draw_functions.c:					pixels[vline.x + env->w * i] = apply_light(texture_pixels[(int)x + texture_w * (int)y], render.light);
src/draw_functions.c:				zbuffer[vline.x + env->w * i] = render.z;
src/draw_functions.c:				/*if (env->options.lighting)
src/draw_functions.c:					pixels[vline.x + env->w * i] = apply_light(0xFF888888, render.light);*/
src/draw_functions.c:	pixels = env->sdl.texture_pixels;
src/draw_functions.c:	zbuffer = env->depth_array;
src/draw_functions.c:	if (env->options.contouring)
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.start >= 0 && vline.start <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.start >= 0 && vline.start < env->h
src/draw_functions.c:					&& render.z <= zbuffer[vline.x + env->w * vline.start])
src/draw_functions.c:				pixels[vline.x + env->w * vline.start] = 0xFF222222;
src/draw_functions.c:				zbuffer[vline.x + env->w * vline.start] = render.z;
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.end >= 0 && vline.end <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.end >= 0 && vline.end < env->h
src/draw_functions.c:					&& render.z <= zbuffer[vline.x + env->w * vline.end])
src/draw_functions.c:				pixels[vline.x + env->w * vline.end] = 0xFF222222;
src/draw_functions.c:				zbuffer[vline.x + env->w * vline.end] = render.z;
src/draw_functions.c:		coord = vline.x + env->w * vline.start;
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.start >= 0 && vline.start <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.start >= 0 && vline.start < env->h
src/draw_functions.c:				/*if (env->options.lighting)
src/draw_functions.c:	pixels = env->sdl.texture_pixels;
src/draw_functions.c:	zbuffer = env->depth_array;
src/draw_functions.c:	if (env->options.contouring)
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.start >= 0 && vline.start <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.start >= 0 && vline.start < env->h)
src/draw_functions.c:				pixels[vline.x + env->w * vline.start] = 0xFF222222;
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.end >= 0 && vline.end <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.end >= 0 && vline.end < env->h)
src/draw_functions.c:				pixels[vline.x + env->w * vline.end] = 0xFF222222;
src/draw_functions.c:	startdist = (env->h / 2.0) / (double)(i - (render.max_floor + render.max_ceiling) / 2.0);
src/draw_functions.c:	startdist = (env->h / 2.0) / (double)(i - render.ceiling_horizon);
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && i >= 0 && i <= 300) || !env->options.show_minimap)
src/draw_functions.c:			//dist = (env->h / 2.0) / (double)(i - (render.max_floor + render.max_ceiling) / 2.0);
src/draw_functions.c:			dist = (env->h / 2.0) / (double)(i - render.ceiling_horizon);
src/draw_functions.c:			//dist = (env->h) / (double)(2.0 * i - env->h);
src/draw_functions.c:			//dist = env->h / (double)(2 * i - env->h);
src/draw_functions.c:			//alpha = (i - render.max_floor) / (double)(env->h - render.max_floor);
src/draw_functions.c:			//alpha = (double)(env->h - render.max_floor) / (double)(i - render.max_floor);
src/draw_functions.c:			y = alpha * render.texel.y + (1.0 - alpha) * env->player.pos.y;
src/draw_functions.c:			//y = alpha * render.texel.y + (1.0 - alpha) * env->screen_pos[render.currentx].y;
src/draw_functions.c:			//y = ((1.0 - alpha) * env->player.pos.y / render.vz1 + alpha * render.texel.y / render.vz2) / ((1.0 - alpha) / render.vz1 + alpha / render.vz2);
src/draw_functions.c:			//y = ((1.0 - alpha) * env->player.pos.y / v0 + alpha * render.texel.y / render.distwall) / ((1.0 - alpha) / v0 + alpha / render.distwall);
src/draw_functions.c:			x = alpha * render.texel.x + (1.0 - alpha) * env->player.pos.x;
src/draw_functions.c:			//x = alpha * render.texel.x + (1.0 - alpha) * env->screen_pos[render.currentx].x;
src/draw_functions.c:			//x = ((1.0 - alpha) * env->player.pos.x / render.vz1 + alpha * render.texel.x / render.vz2) / ((1.0 - alpha) / render.vz1 + alpha / render.vz2);
src/draw_functions.c:			//x = ((1.0 - alpha) * env->player.pos.x / v0 + alpha * render.texel.x / render.distwall) / ((1.0 - alpha) / v0 + alpha / render.distwall);
src/draw_functions.c:			y *= env->textures[render.ceiling_texture].surface->h / 5.0;
src/draw_functions.c:			x *= env->textures[render.ceiling_texture].surface->w / 5.0;
src/draw_functions.c:			while (y >= env->textures[render.ceiling_texture].surface->h)
src/draw_functions.c:				y -= env->textures[render.ceiling_texture].surface->h;
src/draw_functions.c:				y += env->textures[render.ceiling_texture].surface->h;
src/draw_functions.c:			while (x >= env->textures[render.ceiling_texture].surface->w)
src/draw_functions.c:				x -= env->textures[render.ceiling_texture].surface->w;
src/draw_functions.c:				x += env->textures[render.ceiling_texture].surface->w;
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && i >= 0 && i < env->h
src/draw_functions.c:					&& x >= 0 && x < env->textures[render.ceiling_texture].surface->w && y >= 0 && y < env->textures[render.ceiling_texture].surface->h)
src/draw_functions.c:				if (!env->options.lighting)
src/draw_functions.c:					pixels[vline.x + env->w * i] = env->textures[render.ceiling_texture].str[(int)x + env->textures[render.ceiling_texture].surface->w * (int)y];
src/draw_functions.c:					pixels[vline.x + env->w * i] = apply_light(env->textures[render.ceiling_texture].str[(int)x + env->textures[render.ceiling_texture].surface->w * (int)y], render.light);
src/draw_functions.c:	pixels = env->sdl.texture_pixels;
src/draw_functions.c:	zbuffer = env->depth_array;
src/draw_functions.c:	if (env->options.contouring)
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.start >= 0 && vline.start <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.start >= 0 && vline.start < env->h)
src/draw_functions.c:				pixels[vline.x + env->w * vline.start] = 0xFF222222;
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && vline.end >= 0 && vline.end <= 300) || !env->options.show_minimap)
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && vline.end >= 0 && vline.end < env->h)
src/draw_functions.c:				pixels[vline.x + env->w * vline.end] = 0xFF222222;
src/draw_functions.c:	startdist = (env->h / 2.0) / (double)(i - (render.max_floor + render.max_ceiling) / 2.0);
src/draw_functions.c:	startdist = (env->h / 2.0) / (double)(i - render.floor_horizon);
src/draw_functions.c:		if (!(vline.x >= env->w - 300 && vline.x < env->w && i >= 0 && i <= 300) || !env->options.show_minimap)
src/draw_functions.c:			//dist = (env->h / 2.0) / (double)(i - (render.max_floor + render.max_ceiling) / 2.0);
src/draw_functions.c:			dist = (env->h / 2.0) / (double)(i - render.floor_horizon);
src/draw_functions.c:			//dist = (env->h) / (double)(2.0 * i - env->h);
src/draw_functions.c:			//dist = env->h / (double)(2 * i - env->h);
src/draw_functions.c:			//alpha = (i - render.max_floor) / (double)(env->h - render.max_floor);
src/draw_functions.c:			//alpha = (double)(env->h - render.max_floor) / (double)(i - render.max_floor);
src/draw_functions.c:			y = alpha * render.texel.y + (1.0 - alpha) * env->player.pos.y;
src/draw_functions.c:			//y = alpha * render.texel.y + (1.0 - alpha) * env->screen_pos[render.currentx].y;
src/draw_functions.c:			//y = ((1.0 - alpha) * env->player.pos.y / render.vz1 + alpha * render.texel.y / render.vz2) / ((1.0 - alpha) / render.vz1 + alpha / render.vz2);
src/draw_functions.c:			//y = ((1.0 - alpha) * env->player.pos.y / v0 + alpha * render.texel.y / render.distwall) / ((1.0 - alpha) / v0 + alpha / render.distwall);
src/draw_functions.c:			x = alpha * render.texel.x + (1.0 - alpha) * env->player.pos.x;
src/draw_functions.c:			//x = alpha * render.texel.x + (1.0 - alpha) * env->screen_pos[render.currentx].x;
src/draw_functions.c:			//x = ((1.0 - alpha) * env->player.pos.x / render.vz1 + alpha * render.texel.x / render.vz2) / ((1.0 - alpha) / render.vz1 + alpha / render.vz2);
src/draw_functions.c:			//x = ((1.0 - alpha) * env->player.pos.x / v0 + alpha * render.texel.x / render.distwall) / ((1.0 - alpha) / v0 + alpha / render.distwall);
src/draw_functions.c:			y *= env->textures[render.floor_texture].surface->h / 5.0;
src/draw_functions.c:			x *= env->textures[render.floor_texture].surface->w / 5.0;
src/draw_functions.c:			while (y >= env->textures[render.floor_texture].surface->h)
src/draw_functions.c:				y -= env->textures[render.floor_texture].surface->h;
src/draw_functions.c:				y += env->textures[render.floor_texture].surface->h;
src/draw_functions.c:			while (x >= env->textures[render.floor_texture].surface->w)
src/draw_functions.c:				x -= env->textures[render.floor_texture].surface->w;
src/draw_functions.c:				x += env->textures[render.floor_texture].surface->w;
src/draw_functions.c:			if (vline.x >= 0 && vline.x < env->w && i >= 0 && i < env->h
src/draw_functions.c:					&& x >= 0 && x < env->textures[render.floor_texture].surface->w && y >= 0 && y < env->textures[render.floor_texture].surface->h)
src/draw_functions.c:				if (!env->options.lighting)
src/draw_functions.c:					pixels[vline.x + env->w * i] = env->textures[render.floor_texture].str[(int)x + env->textures[render.floor_texture].surface->w * (int)y];
src/draw_functions.c:					pixels[vline.x + env->w * i] = apply_light(env->textures[render.floor_texture].str[(int)x + env->textures[render.floor_texture].surface->w * (int)y], render.light);
src/draw_functions.c:	if (env->options.lighting)
src/draw_functions.c:	if (env->options.lighting)
src/draw_functions.c:	if (env->options.lighting)
src/draw_functions.c:	if (env->options.contouring && (render.currentx == render.x1 || render.currentx == render.x2))
src/draw_functions.c:	if (env->options.lighting)
src/draw_functions.c:	if (env->options.contouring && (render.currentx == render.x1 || render.currentx == render.x2))
src/draw_sprites.c:	sprite = env->sprites[object.sprite];
src/draw_sprites.c:	texture = env->textures[sprite.texture];
src/draw_sprites.c:	pixels = env->sdl.texture_pixels;
src/draw_sprites.c:	zbuffer = env->depth_array;
src/draw_sprites.c:			if (!(x >= env->w - 300 && x < env->w && y >= 0 && y <= 300) || !env->options.show_minimap)
src/draw_sprites.c:				if (x >= 0 && x < env->w && y >= 0 && y < env->h
src/draw_sprites.c:						&& object.rotated_pos.z < env->depth_array[x + y * env->w]
src/draw_sprites.c:					if (!env->options.lighting)
src/draw_sprites.c:						pixels[x + y * env->w] = texture_pixels[textx + texty * texture.surface->w];
src/draw_sprites.c:						pixels[x + y * env->w] = apply_light(texture_pixels[textx + texty * texture.surface->w], light);
src/draw_sprites.c:					zbuffer[x + y * env->w] = object.rotated_pos.z;
src/draw_sprites.c:	while (i < env->nb_objects)
src/draw_sprites.c:		get_translated_object_pos(&env->objects[i], env);
src/draw_sprites.c:		get_rotated_object_pos(&env->objects[i], env);
src/draw_sprites.c:		//ft_printf("object z = %f\n", env->objects[i].rotated_pos.z);
src/draw_sprites.c:	//sort_objects(env->objects, 0, env->nb_objects - 1);
src/draw_sprites.c:	while (i < env->nb_objects)
src/draw_sprites.c:		draw_object(env->objects[i], env, render);
src/fps.c:	env->fps = ft_sitoa(1000 / (new_time - env->sdl.time));
src/fps.c:	if (env->options.show_fps)
src/fps.c:					env->fps,
src/fps.c:					env->sdl.fonts.amazdoom50,
src/fps.c:	env->sdl.time = new_time;
src/free_all.c:		if (env->textures[i].surface)
src/free_all.c:			SDL_FreeSurface(env->textures[i].surface);
src/free_all.c:	while (i < env->nb_sectors)
src/free_all.c:		if (env->sectors[i].vertices)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].vertices);
src/free_all.c:		if (env->sectors[i].ceilings)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].ceilings);
src/free_all.c:		if (env->sectors[i].floors)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].floors);
src/free_all.c:		if (env->sectors[i].clipped_ceilings1)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_ceilings1);
src/free_all.c:		if (env->sectors[i].clipped_floors1)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_floors1);
src/free_all.c:		if (env->sectors[i].clipped_ceilings2)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_ceilings2);
src/free_all.c:		if (env->sectors[i].clipped_floors2)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_floors2);
src/free_all.c:		if (env->sectors[i].wall_width)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].wall_width);
src/free_all.c:		if (env->sectors[i].textures)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].textures);
src/free_all.c:		if (env->sectors[i].neighbors)
src/free_all.c:			ft_memdel((void**)&env->sectors[i].neighbors);
src/free_all.c:	ft_memdel((void**)&env->sectors);
src/free_all.c:	if (env->sdl.window)
src/free_all.c:		SDL_DestroyWindow(env->sdl.window);
src/free_all.c:	if (env->sdl.renderer)
src/free_all.c:		SDL_DestroyRenderer(env->sdl.renderer);
src/free_all.c:	if (env->sdl.surface)
src/free_all.c:		SDL_FreeSurface(env->sdl.surface);
src/free_all.c:	if (env->sdl.texture_pixels)
src/free_all.c:		ft_memdel((void**)&env->sdl.texture_pixels);
src/free_all.c:	if (env->depth_array)
src/free_all.c:		ft_memdel((void**)&env->depth_array);
src/free_all.c:	if (env->sdl.fonts.amazdoom50)
src/free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom50);
src/free_all.c:	if (env->sdl.fonts.amazdoom20)
src/free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom20);
src/free_all.c:	if (env->sdl.fonts.alice30)
src/free_all.c:		TTF_CloseFont(env->sdl.fonts.alice30);
src/free_all.c:	if (env->sdl.fonts.alice70)
src/free_all.c:		TTF_CloseFont(env->sdl.fonts.alice70);
src/free_all.c:	if (env->sdl.fonts.bebasneue)
src/free_all.c:		TTF_CloseFont(env->sdl.fonts.bebasneue);
src/free_all.c:	if (env->sectors)
src/free_all.c:	if (env->vertices)
src/free_all.c:		ft_memdel((void**)&env->vertices);
src/free_all.c:	if (env->objects)
src/free_all.c:		ft_memdel((void**)&env->objects);
src/free_all.c:	if (env->xmin)
src/free_all.c:		ft_memdel((void**)&env->xmin);
src/free_all.c:	if (env->xmax)
src/free_all.c:		ft_memdel((void**)&env->xmax);
src/free_all.c:	if (env->screen_sectors)
src/free_all.c:		ft_memdel((void**)&env->screen_sectors);
src/free_all.c:	if (env->rendered_sectors)
src/free_all.c:		ft_memdel((void**)&env->rendered_sectors);
src/free_all.c:	if (env->depth_array)
src/free_all.c:		ft_memdel((void**)&env->depth_array);
src/free_all.c:	if (env->screen_pos)
src/free_all.c:		ft_memdel((void**)&env->screen_pos);
src/free_all.c:	if (env->sound.background)
src/free_all.c:		Mix_FreeMusic(env->sound.background);
src/free_all.c:	if (env->sound.footstep)
src/free_all.c:		Mix_FreeChunk(env->sound.footstep);
src/free_all.c:	if (env->sound.footstep)
src/free_all.c:		Mix_FreeChunk(env->sound.jump);
src/free_all.c:		if (env->weapons[i].empty)
src/free_all.c:			Mix_FreeChunk(env->weapons[i].empty);
src/free_all.c:		if (env->weapons[i].sound)
src/free_all.c:			Mix_FreeChunk(env->weapons[i].sound);
src/get_screen_sectors.c:	size = ft_min(env->nb_sectors, env->w);
src/get_screen_sectors.c:	while (x < env->w)
src/get_screen_sectors.c:		tmp = 2 * x / (env->camera.x2 - env->camera.x1) / env->camera.scale + env->camera.x1;
src/get_screen_sectors.c:		curr.y = -env->camera.near_z;
src/get_screen_sectors.c:		curr.x = tmp * -env->player.angle_sin - curr.y * env->player.angle_cos + env->player.pos.x;
src/get_screen_sectors.c:		curr.y = tmp * env->player.angle_cos - curr.y * env->player.angle_sin + env->player.pos.y;
src/get_screen_sectors.c:		env->screen_pos[x] = curr;
src/get_screen_sectors.c:		while (i < env->screen_sectors_size && env->screen_sectors[i] != -1 && env->screen_sectors[i] != sect)
src/get_screen_sectors.c:		if (i < env->screen_sectors_size && env->screen_sectors[i] == -1 && sect != -1)
src/get_screen_sectors.c:			env->screen_sectors[i] = sect;
src/get_screen_sectors.c:			env->xmin[i] = x;
src/get_screen_sectors.c:		else if (i < env->screen_sectors_size && env->screen_sectors[i] == sect)
src/get_screen_sectors.c:			env->xmax[i] = x;
src/get_slope.c:	v1 = env->vertices[sector.vertices[0]];
src/get_slope.c:	v2 = env->vertices[sector.vertices[1]];
src/get_slope.c:	v0 = env->vertices[sector.vertices[0]];
src/get_slope.c:	v1 = env->vertices[sector.vertices[1]];
src/get_slope.c:	vi = env->vertices[sector.vertices[vertex_nb]];
src/get_slope.c:	v0 = env->vertices[sector.vertices[0]];
src/get_slope.c:	v0 = env->vertices[sector.vertices[0]];
src/get_slope.c:	v0 = env->vertices[sector.vertices[0]];
src/get_slope.c:	v0 = env->vertices[sector.vertices[0]];
src/get_slope.c:	while (i < env->nb_sectors)
src/get_slope.c:		ft_printf("sector %d normal = [%f,%f]\n", i, env->sectors[i].normal.x, env->sectors[i].normal.y);
src/get_slope.c:		ft_printf("floor = %f\nceiling = %f\n", env->sectors[i].floor, env->sectors[i].ceiling);
src/get_slope.c:		ft_printf("floor_slope = %f\nceiling_slope = %f\n", env->sectors[i].floor_slope, env->sectors[i].ceiling_slope);
src/get_slope.c:		while (j < env->sectors[i].nb_vertices)
src/get_slope.c:			printf("vertex %d floor = %f ceiling = %f\n", j, env->sectors[i].floors[j], env->sectors[i].ceilings[j]);
src/get_slope.c:	if (sector_nb < 0 || sector_nb > env->nb_sectors)
src/get_slope.c:	sector = env->sectors[sector_nb];
src/get_slope.c:	env->sectors[sector_nb].floor_max = sector.floor;
src/get_slope.c:	env->sectors[sector_nb].floor_min = sector.floor;
src/get_slope.c:	env->sectors[sector_nb].ceiling_max = sector.ceiling;
src/get_slope.c:	env->sectors[sector_nb].ceiling_min = sector.ceiling;
src/get_slope.c:			env->sectors[sector_nb].floors[i] = get_floor(sector,
src/get_slope.c:					env->vertices[sector.vertices[i]], env); 
src/get_slope.c:			env->sectors[sector_nb].floors[i] = sector.floor;
src/get_slope.c:			env->sectors[sector_nb].ceilings[i] = get_ceiling(sector,
src/get_slope.c:					env->vertices[sector.vertices[i]], env); 
src/get_slope.c:			env->sectors[sector_nb].ceilings[i] = sector.ceiling;
src/get_slope.c:		if (env->sectors[sector_nb].floors[i]
src/get_slope.c:				< env->sectors[sector_nb].floor_min)
src/get_slope.c:			env->sectors[sector_nb].floor_min
src/get_slope.c:				= env->sectors[sector_nb].floors[i];
src/get_slope.c:		if (env->sectors[sector_nb].floors[i] 
src/get_slope.c:			> env->sectors[sector_nb].floor_max)
src/get_slope.c:			env->sectors[sector_nb].floor_max
src/get_slope.c:				= env->sectors[sector_nb].floors[i];
src/get_slope.c:		if (env->sectors[sector_nb].ceilings[i]
src/get_slope.c:				> env->sectors[sector_nb].ceiling_max)
src/get_slope.c:			env->sectors[sector_nb].ceiling_max
src/get_slope.c:				= env->sectors[sector_nb].ceilings[i];
src/get_slope.c:		if (env->sectors[sector_nb].ceilings[i]
src/get_slope.c:				< env->sectors[sector_nb].ceiling_min)
src/get_slope.c:			env->sectors[sector_nb].ceiling_min
src/get_slope.c:				= env->sectors[sector_nb].ceilings[i];
src/get_slope.c:		env->sectors[sector_nb].wall_width[i] = sqrt(
src/get_slope.c:				pow(env->vertices[sector.vertices[i + 1]].x
src/get_slope.c:					- env->vertices[sector.vertices[i]].x, 2)
src/get_slope.c:				+ pow(env->vertices[sector.vertices[i + 1]].y
src/get_slope.c:					- env->vertices[sector.vertices[i]].y, 2));
src/get_slope.c:	env->sectors[sector_nb].floors[i] = env->sectors[sector_nb].floors[0];
src/get_slope.c:	env->sectors[sector_nb].ceilings[i] = env->sectors[sector_nb].ceilings[0];
src/get_slope.c:	while (i < env->nb_sectors)
src/get_slope.c:		env->sectors[i].normal = get_sector_normal(env->sectors[i], env);
src/init_animations.c:	env->time.start = 0;
src/init_animations.c:	env->time.end = 0;
src/init_animations.c:	env->player.state = 0;
src/init_animations.c:	env->gravity.on_going = 1;
src/init_animations.c:	env->gravity.start = 0;
src/init_animations.c:	env->gravity.end = 0;
src/init_animations.c:	env->gravity.weight = 1;
src/init_animations.c:	env->jump.on_going = 0;
src/init_animations.c:	env->jump.start = 0;
src/init_animations.c:	env->jump.end = 235;
src/init_animations.c:	env->jump.nb_frame = 15;
src/init_animations.c:	env->squat.on_going = 0;
src/init_animations.c:	env->squat.start = 0;
src/init_animations.c:	env->squat.end = 0;
src/init_animations.c:	env->shot.on_going = 0;
src/init_animations.c:	env->shot.start = 0;
src/init_animations.c:	env->weapon_change.on_going = 0;
src/init_animations.c:	env->weapon_change.start = 0;
src/init_camera.c:	env->camera.vfov = (180.0 / M_PI) * atan(tan(((CONVERT_RADIANS) * env->camera.hfov / 2)) / env->camera.ratio) * 2;
src/init_camera.c:	//env->camera.hfov = (180.0 / M_PI) * atan(tan(((M_PI / 180.0) * env->cameravfov / 2)) * env->camera.ratio) * 2;
src/init_camera.c:	//ft_printf("hfov = %f, vfov = %f\n", env->camera.hfov, env->camera.vfov);
src/init_camera.c:	env->camera.near_left = -tan((CONVERT_RADIANS) * env->camera.hfov / 2) * env->camera.near_z;
src/init_camera.c:	env->camera.near_right = tan((CONVERT_RADIANS) * env->camera.hfov / 2) * env->camera.near_z;
src/init_camera.c:	env->camera.near_up = -tan((CONVERT_RADIANS) * env->camera.vfov / 2) * env->camera.near_z;
src/init_camera.c:	env->camera.near_down = tan((CONVERT_RADIANS) * env->camera.vfov / 2) * env->camera.near_z;
src/init_camera.c:	env->camera.far_left = -tan((CONVERT_RADIANS) * env->camera.hfov / 2) * env->camera.far_z;
src/init_camera.c:	env->camera.far_right = tan((CONVERT_RADIANS) * env->camera.hfov / 2) * env->camera.far_z;
src/init_camera.c:	env->camera.x1 = (env->camera.near_left / env->camera.near_z);
src/init_camera.c:	env->camera.x2 = (env->camera.near_right / env->camera.near_z);
src/init_camera.c:	env->camera.y1 = (env->camera.near_up / env->camera.near_z);
src/init_camera.c:	env->camera.y2 = (env->camera.near_down / env->camera.near_z);
src/init_camera.c:	env->camera.hscale = env->w / 2 / env->camera.x2;
src/init_camera.c:	env->camera.vscale = env->h / 2 / env->camera.y2;
src/init_camera.c:	env->camera.scale = env->camera.vscale;
src/init_camera.c:			env->camera.near_z,
src/init_camera.c:			env->camera.near_left,
src/init_camera.c:			env->camera.near_right,
src/init_camera.c:			env->camera.far_left,
src/init_camera.c:			env->camera.far_right);
src/init_camera.c:	ft_printf("camera x1 = %f camera x2 = %f\n", env->camera.x1, env->camera.x2);
src/init_camera.c:	ft_printf("near_up = %f near_down = %f\n", env->camera.near_up, env->camera.near_down);
src/init_camera.c:	ft_printf("camera y1 = %f camera y2 = %f\n", env->camera.y1, env->camera.y2);
src/init_camera.c:	ft_printf("hscale = %f\n", env->camera.hscale);
src/init_camera.c:	ft_printf("vscale = %f\n", env->camera.vscale);
src/init_camera.c:	ft_printf("final scale = %f\n", env->camera.scale);*/
src/init_camera.c:	env->camera.hfov = 90;
src/init_camera.c:	env->camera.near_z = 1;
src/init_camera.c:	env->camera.far_z = 1000;
src/init_camera.c:	env->camera.ratio_w = 16;
src/init_camera.c:	env->camera.ratio_h = 9;
src/init_camera.c:	env->camera.ratio = env->camera.ratio_w / env->camera.ratio_h;
src/init_keys.c:	env->keys.forward = SDLK_w;
src/init_keys.c:	env->keys.backward = SDLK_s;
src/init_keys.c:	env->keys.left = SDLK_a;
src/init_keys.c:	env->keys.right = SDLK_d;
src/init_keys.c:	env->keys.forward2 = SDLK_UP;
src/init_keys.c:	env->keys.backward2 = SDLK_DOWN;
src/init_keys.c:	env->keys.left2 = SDLK_LEFT;
src/init_keys.c:	env->keys.right2 = SDLK_RIGHT;
src/init_keys.c:	env->keys.plus = SDLK_KP_PLUS;
src/init_keys.c:	env->keys.minus = SDLK_KP_MINUS;
src/init_keys.c:	env->keys.shift = SDLK_LSHIFT;
src/init_keys.c:	env->keys.ctrl = SDLK_LCTRL;
src/init_keys.c:	env->keys.space = SDLK_SPACE;
src/init_keys.c:	env->keys.up = SDLK_PAGEUP;
src/init_keys.c:	env->keys.down = SDLK_PAGEDOWN;
src/init_keys.c:	env->keys.option = SDLK_o;
src/init_options.c:	env->options.contouring = 1;
src/init_options.c:	env->options.render_sectors = 1;
src/init_options.c:	env->options.lighting = 0;
src/init_options.c:	env->options.show_minimap = 1;
src/init_options.c:	env->options.wall_lover = 0;
src/init_options.c:	env->options.show_fps = 1;
src/init_options.c:	env->options.color_clipping = 0;
src/init_options.c:	env->options.wall_color = 1;
src/init_options.c:	env->options.test = 0;
src/init_options.c:	env->options.minimap_scale = 10;
src/init_options.c:	env->options.clipping = 1;
src/init_options.c:	env->option = 0;
src/init_options.c:	env->options.show_ennemies = 1;
src/init_pointers.c:	env->sectors = NULL;
src/init_pointers.c:	env->vertices = NULL;
src/init_pointers.c:	env->objects = NULL;
src/init_pointers.c:	env->sdl.window = NULL;
src/init_pointers.c:	env->sdl.renderer = NULL;
src/init_pointers.c:	env->sdl.surface = NULL;
src/init_pointers.c:	env->sdl.texture = NULL;
src/init_pointers.c:	env->sdl.img_str = NULL;
src/init_pointers.c:	env->sdl.texture_pixels = NULL;
src/init_pointers.c:	env->xmin = NULL;
src/init_pointers.c:	env->xmax = NULL;
src/init_pointers.c:	env->screen_sectors = NULL;
src/init_pointers.c:	env->depth_array = NULL;
src/init_pointers.c:	env->rendered_sectors = NULL;
src/init_pointers.c:	env->sdl.fonts.amazdoom20 = NULL;
src/init_pointers.c:	env->sdl.fonts.amazdoom50 = NULL;
src/init_pointers.c:	env->sdl.fonts.bebasneue = NULL;
src/init_pointers.c:	env->sdl.fonts.alice30 = NULL;
src/init_pointers.c:	env->sdl.fonts.alice70 = NULL;
src/init_pointers.c:	env->screen_pos = NULL;
src/init_pointers.c:	env->sound.background = NULL;
src/init_pointers.c:	env->sound.footstep = NULL;
src/init_pointers.c:	env->sound.jump = NULL;
src/init_pointers.c:		env->textures[i].surface = NULL;
src/init_pointers.c:		env->textures[i].str = NULL;
src/init_pointers.c:		env->weapons[i].sound = NULL;
src/init_pointers.c:		env->weapons[i].empty = NULL;
src/init_sdl.c:	if (!(env->sdl.window = SDL_CreateWindow(
src/init_sdl.c:					env->w,
src/init_sdl.c:					env->h,
src/init_sdl.c:	if (!(env->sdl.renderer = SDL_CreateRenderer(
src/init_sdl.c:					env->sdl.window,
src/init_sdl.c:	SDL_GetRendererInfo(env->sdl.renderer, &info);
src/init_sdl.c:	/*if (SDL_SetRenderDrawBlendMode(env->sdl.renderer, SDL_BLENDMODE_NONE))
src/init_sdl.c:	if (!(env->sdl.surface = SDL_CreateRGBSurfaceWithFormat(
src/init_sdl.c:					env->w,
src/init_sdl.c:					env->h,
src/init_sdl.c:	if (SDL_SetSurfaceBlendMode(env->sdl.surface, SDL_BLENDMODE_BLEND))
src/init_sdl.c:	env->sdl.img_str = env->sdl.surface->pixels;
src/init_sdl.c:	if (!(env->sdl.texture = SDL_CreateTexture(
src/init_sdl.c:					env->sdl.renderer,
src/init_sdl.c:					env->w,
src/init_sdl.c:					env->h)))
src/init_sdl.c:	if (!(env->sdl.texture_pixels = (Uint32*)malloc(sizeof(Uint32) * env->w * env->h)))
src/init_sdl.c:	if (!(env->depth_array = (double*)malloc(sizeof(double) * env->w * env->h)))
src/init_sdl.c:				env->sdl.renderer,
src/init_sdl.c:				env->sdl.texture,
src/init_sdl.c:	SDL_RenderPresent(env->sdl.renderer);
src/init_sdl.c:	env->time.milli_s =  0;
src/init_sound.c:	env->sound.b_jump = 20;
src/init_sound.c:	env->sound.b_footstep = 20;
src/init_sound.c:	env->sound.b_weapon = 20;
src/init_sound.c:	env->sound.g_music = 20;
src/init_sound.c:	if(!(env->sound.background = Mix_LoadMUS("audio/at_dooms_gate.mp3")))
src/init_sound.c:	if (!(env->sound.footstep = Mix_LoadWAV("audio/footstep.wav")))
src/init_sound.c:	if (!(env->sound.jump = Mix_LoadWAV("audio/jump.wav")))
src/init_sound.c:	if (!(env->weapons[0].sound = Mix_LoadWAV("audio/shotgun_shot.wav")))
src/init_sound.c:	if (!(env->weapons[0].empty = Mix_LoadWAV("audio/shotgun_no_ammo.wav")))
src/init_sound.c:	if (!(env->weapons[1].sound = Mix_LoadWAV("audio/raygun_shot.wav")))
src/init_sound.c:	if (!(env->weapons[1].empty = Mix_LoadWAV("audio/shotgun_no_ammo.wav")))
src/init_sound.c:	Mix_VolumeChunk(env->sound.jump, MIX_MAX_VOLUME / env->sound.b_jump);
src/init_sound.c:	Mix_VolumeChunk(env->sound.footstep, MIX_MAX_VOLUME / env->sound.b_footstep);
src/init_sound.c:	Mix_VolumeChunk(env->weapons[0].sound, MIX_MAX_VOLUME / env->sound.b_weapon);
src/init_sound.c:	Mix_VolumeChunk(env->weapons[1].sound, MIX_MAX_VOLUME / env->sound.b_weapon);
src/init_sprites.c:	if (!(env->sprites = (t_sprite*)malloc(sizeof(t_sprite) * 2)))
src/init_sprites.c:	env->sprites[0].texture = 33;
src/init_sprites.c:	env->sprites[0].oriented = 0;
src/init_sprites.c:	env->sprites[0].reversed[0] = 0;
src/init_sprites.c:	env->sprites[0].start[0].x = 511;
src/init_sprites.c:	env->sprites[0].start[0].y = 78;
src/init_sprites.c:	env->sprites[0].end[0].x = 562;
src/init_sprites.c:	env->sprites[0].end[0].y = 102;
src/init_sprites.c:	env->sprites[0].size[0].x = 51;
src/init_sprites.c:	env->sprites[0].size[0].y = 24;
src/init_sprites.c:	env->sprites[0].width = 2;
src/init_sprites.c:	env->sprites[0].height = 2;
src/init_sprites.c:	env->sprites[1].texture = 34;
src/init_sprites.c:	env->sprites[1].oriented = 1;
src/init_sprites.c:	env->sprites[1].width = 2;
src/init_sprites.c:	env->sprites[1].height = 2;
src/init_sprites.c:	env->sprites[1].start[0].x = 44;
src/init_sprites.c:	env->sprites[1].start[0].y = 120;
src/init_sprites.c:	env->sprites[1].end[0].x = 87;
src/init_sprites.c:	env->sprites[1].end[0].y = 165;
src/init_sprites.c:	env->sprites[1].size[0].x = 44;
src/init_sprites.c:	env->sprites[1].size[0].y = 46;
src/init_sprites.c:	env->sprites[1].reversed[0] = 0;
src/init_sprites.c:	env->sprites[1].start[1].x = 374;
src/init_sprites.c:	env->sprites[1].start[1].y = 120;
src/init_sprites.c:	env->sprites[1].end[1].x = 405;
src/init_sprites.c:	env->sprites[1].end[1].y = 172;
src/init_sprites.c:	env->sprites[1].size[1].x = 32;
src/init_sprites.c:	env->sprites[1].size[1].y = 53;
src/init_sprites.c:	env->sprites[1].reversed[1] = 0;
src/init_sprites.c:	env->sprites[1].start[2].x = 299;
src/init_sprites.c:	env->sprites[1].start[2].y = 120;
src/init_sprites.c:	env->sprites[1].end[2].x = 329;
src/init_sprites.c:	env->sprites[1].end[2].y = 173;
src/init_sprites.c:	env->sprites[1].size[2].x = 31;
src/init_sprites.c:	env->sprites[1].size[2].y = 54;
src/init_sprites.c:	env->sprites[1].reversed[2] = 0;
src/init_sprites.c:	env->sprites[1].start[3].x = 220;
src/init_sprites.c:	env->sprites[1].start[3].y = 120;
src/init_sprites.c:	env->sprites[1].end[3].x = 254;
src/init_sprites.c:	env->sprites[1].end[3].y = 171;
src/init_sprites.c:	env->sprites[1].size[3].x = 35;
src/init_sprites.c:	env->sprites[1].size[3].y = 52;
src/init_sprites.c:	env->sprites[1].reversed[3] = 0;
src/init_sprites.c:	env->sprites[1].start[4].x = 132;
src/init_sprites.c:	env->sprites[1].start[4].y = 120;
src/init_sprites.c:	env->sprites[1].end[4].x = 175;
src/init_sprites.c:	env->sprites[1].end[4].y = 165;
src/init_sprites.c:	env->sprites[1].size[4].x = 44;
src/init_sprites.c:	env->sprites[1].size[4].y = 46;
src/init_sprites.c:	env->sprites[1].reversed[4] = 0;
src/init_sprites.c:	env->sprites[1].start[5].x = 220;
src/init_sprites.c:	env->sprites[1].start[5].y = 120;
src/init_sprites.c:	env->sprites[1].end[5].x = 254;
src/init_sprites.c:	env->sprites[1].end[5].y = 171;
src/init_sprites.c:	env->sprites[1].size[5].x = 35;
src/init_sprites.c:	env->sprites[1].size[5].y = 52;
src/init_sprites.c:	env->sprites[1].reversed[5] = 1;
src/init_sprites.c:	env->sprites[1].start[6].x = 299;
src/init_sprites.c:	env->sprites[1].start[6].y = 120;
src/init_sprites.c:	env->sprites[1].end[6].x = 329;
src/init_sprites.c:	env->sprites[1].end[6].y = 173;
src/init_sprites.c:	env->sprites[1].size[6].x = 31;
src/init_sprites.c:	env->sprites[1].size[6].y = 54;
src/init_sprites.c:	env->sprites[1].reversed[6] = 1;
src/init_sprites.c:	env->sprites[1].start[7].x = 374;
src/init_sprites.c:	env->sprites[1].start[7].y = 120;
src/init_sprites.c:	env->sprites[1].end[7].x = 405;
src/init_sprites.c:	env->sprites[1].end[7].y = 172;
src/init_sprites.c:	env->sprites[1].size[7].x = 32;
src/init_sprites.c:	env->sprites[1].size[7].y = 53;
src/init_sprites.c:	env->sprites[1].reversed[7] = 1;
src/init_ttf.c:	//env->sdl.font = TTF_OpenFont("fonts/heartwrecked.ttf", 65);
src/init_ttf.c:	env->sdl.fonts.amazdoom70 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 70);
src/init_ttf.c:	env->sdl.fonts.amazdoom50 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 50);
src/init_ttf.c:	env->sdl.fonts.amazdoom20 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 20);
src/init_ttf.c:	env->sdl.fonts.alice30 = TTF_OpenFont("fonts/alice/Alice-Regular.ttf", 30);
src/init_ttf.c:	env->sdl.fonts.alice70 = TTF_OpenFont("fonts/alice/Alice-Regular.ttf", 70);
src/init_ttf.c:	env->sdl.fonts.bebasneue = TTF_OpenFont("fonts/bebas_neue/BebasNeue-Regular.ttf", 20);
src/init_weapons.c:	env->weapons[0].possessed = 1;
src/init_weapons.c:    env->weapons[0].weapon_switch = 0;
src/init_weapons.c:    env->weapons[0].first_sprite = 6;
src/init_weapons.c:    env->weapons[0].nb_sprites = 15;
src/init_weapons.c:    env->weapons[0].ammo = 2;
src/init_weapons.c:    env->weapons[0].no_ammo = 0;
src/init_weapons.c:    env->weapons[0].max_ammo = 20;
src/init_weapons.c:	env->weapons[1].possessed = 1;
src/init_weapons.c:    env->weapons[1].first_sprite = 21;
src/init_weapons.c:    env->weapons[1].nb_sprites = 7;
src/init_weapons.c:    env->weapons[1].ammo = 40;
src/init_weapons.c:    env->weapons[1].max_ammo = 40;
src/init_weapons.c:    env->weapons[1].no_ammo = 0;
src/inputs.c:	env->inputs.forward = 0;
src/inputs.c:	env->inputs.backward = 0;
src/inputs.c:	env->inputs.left = 0;
src/inputs.c:	env->inputs.right = 0;
src/inputs.c:	env->inputs.plus = 0;
src/inputs.c:	env->inputs.minus = 0;
src/inputs.c:	env->inputs.shift = 0;
src/inputs.c:	env->inputs.ctrl = 0;
src/inputs.c:	env->inputs.space = 0;
src/inputs.c:	env->inputs.ctrl = 0;
src/inputs.c:	env->inputs.option = 0;
src/inputs.c:	env->inputs.left_click = 0;
src/inputs.c:	if (env->button[nb].image == 30 || env->button[nb].image == 31)
src/inputs.c:		xmax = env->button[nb].x + 40;
src/inputs.c:		ymax = env->button[nb].y + 40;
src/inputs.c:		xmax = env->button[nb].x + 150;
src/inputs.c:		ymax = env->button[nb].y + 150;
src/inputs.c:	if ((env->sdl.mx >= env->button[nb].x
src/inputs.c:		&& env->sdl.mx <= xmax)
src/inputs.c:		&& (env->sdl.my >=  env->button[nb].y
src/inputs.c:		&& env->sdl.my <= ymax))
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.forward
src/inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.forward2)
src/inputs.c:		env->inputs.forward = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.backward
src/inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.backward2)
src/inputs.c:		env->inputs.backward = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.left
src/inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.left2)
src/inputs.c:		env->inputs.left = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.right
src/inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.right2)
src/inputs.c:		env->inputs.right = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.plus)
src/inputs.c:		env->inputs.plus = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.minus)
src/inputs.c:		env->inputs.minus = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.shift)
src/inputs.c:		env->inputs.shift = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.space)
src/inputs.c:		env->inputs.space = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.ctrl)
src/inputs.c:		env->inputs.ctrl = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.up)
src/inputs.c:		env->inputs.up = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.down)
src/inputs.c:		env->inputs.down = mode;
src/inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.option)
src/inputs.c:		env->inputs.option = mode;
src/inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT)
src/inputs.c:		env->inputs.leftclick = mode;
src/inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_RIGHT && mode == 1 && !env->option)
src/inputs.c:		if (env->weapons[env->player.curr_weapon].ammo < env->weapons[env->player.curr_weapon].max_ammo)
src/inputs.c:			env->weapons[env->player.curr_weapon].ammo++;
src/inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT && env->option)
src/inputs.c:		env->inputs.left_click  = env->inputs.left_click ? 0 : 1;
src/inputs.c:		if (env->inputs.left_click
src/inputs.c:			&& env->i > 0)
src/inputs.c:			env->i--;
src/inputs.c:		else if (env->inputs.left_click
src/inputs.c:			&& env->i < 2)
src/inputs.c:			env->i++;
src/inputs.c:		else if (env->inputs.left_click
src/inputs.c:			&& env->sound.g_music > 5)
src/inputs.c:			env->sound.g_music -= 5;
src/inputs.c:		else if (env->inputs.left_click
src/inputs.c:			&& env->sound.g_music < 100)
src/inputs.c:			env->sound.g_music += 5;
src/inputs.c:		else if (env->inputs.left_click
src/inputs.c:			env->aplicate_changes = 1;
src/inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT
src/inputs.c:	&& env->menu_start
src/inputs.c:		env->menu_start = 0;
src/inputs.c:	if (env->sdl.event.type == SDL_KEYDOWN)
src/inputs.c:	if (env->sdl.event.type == SDL_KEYUP)
src/inputs.c:	if (env->sdl.event.type == SDL_MOUSEBUTTONDOWN)
src/inputs.c: 	if (env->sdl.event.type == SDL_MOUSEBUTTONUP)
src/inputs.c:	if (env->sdl.event.type == SDL_MOUSEWHEEL && !env->weapon_change.on_going && !env->shot.on_going)
src/intersections.c:	if (render->inter_left.x >= env->camera.far_left
src/intersections.c:			&& render->inter_left.x <= env->camera.near_left
src/intersections.c:			&& render->inter_left.y <= env->camera.far_z
src/intersections.c:			&& render->inter_left.y >= env->camera.near_z)
src/intersections.c:	if (render->vz1 < env->camera.near_z)
src/keys.c:	if (!env->jump.on_going && env->inputs.space)
src/keys.c:	if (env->inputs.forward || env->inputs.backward || env->inputs.left
src/keys.c:			|| env->inputs.right)
src/keys.c:		Mix_PlayChannel(-1, env->sound.footstep, 0);
src/keys.c:	if (env->inputs.forward || env->inputs.backward || env->inputs.left
src/keys.c:			|| env->inputs.right || env->inputs.space || env->jump.on_going == 1
src/keys.c:			|| env->squat.on_going || env->inputs.ctrl || env->gravity.on_going)
src/keys.c:	if (env->inputs.plus && !env->inputs.shift
src/keys.c:			&& env->options.minimap_scale * 1.2 < 100)
src/keys.c:		env->options.minimap_scale *= 1.2;
src/keys.c:	if (env->inputs.minus && !env->inputs.shift
src/keys.c:			&& env->options.minimap_scale / 1.2 > 5)
src/keys.c:		env->options.minimap_scale /= 1.2;
src/keys.c:	if (env->inputs.up && !env->inputs.shift)
src/keys.c:		env->sectors[env->player.sector].floor_slope += 0.01;
src/keys.c:		update_sector_slope(env, env->player.sector);
src/keys.c:		if (env->sectors[env->player.sector].floor_max
src/keys.c:			> env->sectors[env->player.sector].ceiling_min)
src/keys.c:			env->sectors[env->player.sector].floor_slope -= 0.01;
src/keys.c:			update_sector_slope(env, env->player.sector);
src/keys.c:	if (env->inputs.down && !env->inputs.shift)
src/keys.c:		env->sectors[env->player.sector].floor_slope -= 0.01;
src/keys.c:		update_sector_slope(env, env->player.sector);
src/keys.c:	if (env->inputs.up && env->inputs.shift)
src/keys.c:		env->sectors[env->player.sector].ceiling_slope += 0.01;
src/keys.c:		update_sector_slope(env, env->player.sector);
src/keys.c:	if (env->inputs.down && env->inputs.shift)
src/keys.c:		env->sectors[env->player.sector].ceiling_slope -= 0.01;
src/keys.c:		update_sector_slope(env, env->player.sector);
src/keys.c:		if (env->sectors[env->player.sector].floor_max
src/keys.c:			> env->sectors[env->player.sector].ceiling_min)
src/keys.c:			env->sectors[env->player.sector].ceiling_slope += 0.01;
src/keys.c:			update_sector_slope(env, env->player.sector);
src/map_parse_objects.c:	env->nb_objects = 3;
src/map_parse_objects.c:	env->objects = (t_object*)malloc(sizeof(t_object) * env->nb_objects);
src/map_parse_objects.c:	env->objects[0].sprite = 0;
src/map_parse_objects.c:	env->objects[0].pickable = 0;
src/map_parse_objects.c:	env->objects[0].solid = 0;
src/map_parse_objects.c:	env->objects[0].pos.x = 5;
src/map_parse_objects.c:	env->objects[0].pos.y = 5;
src/map_parse_objects.c:	env->objects[0].pos.z = 0;
src/map_parse_objects.c:	env->objects[0].scale = 60;
src/map_parse_objects.c:	env->objects[0].sector = 0;
src/map_parse_objects.c:	env->objects[1].sprite = 1;
src/map_parse_objects.c:	env->objects[1].pickable = 0;
src/map_parse_objects.c:	env->objects[1].solid = 0;
src/map_parse_objects.c:	env->objects[1].pos.x = 20;
src/map_parse_objects.c:	env->objects[1].pos.y = 10;
src/map_parse_objects.c:	env->objects[1].pos.z = 6;
src/map_parse_objects.c:	env->objects[1].scale = 60;
src/map_parse_objects.c:	env->objects[1].sector = 0;
src/map_parse_objects.c:	env->objects[1].angle = 90;
src/map_parse_objects.c:	env->objects[2].sprite = 1;
src/map_parse_objects.c:	env->objects[2].pickable = 0;
src/map_parse_objects.c:	env->objects[2].solid = 0;
src/map_parse_objects.c:	env->objects[2].pos.x = 10;
src/map_parse_objects.c:	env->objects[2].pos.y = 20;
src/map_parse_objects.c:	env->objects[2].pos.z = 6;
src/map_parse_objects.c:	env->objects[2].scale = 60;
src/map_parse_objects.c:	env->objects[2].sector = 0;
src/map_parse_objects.c:	env->objects[2].angle = -90;
src/map_parse_objects.c:	/*env->objects[0].sprite = 0;
src/map_parse_objects.c:	env->objects[0].pickable = 0;
src/map_parse_objects.c:	env->objects[0].solid = 0;
src/map_parse_objects.c:	env->objects[0].pos.x = 17.5;
src/map_parse_objects.c:	env->objects[0].pos.y = -2;
src/map_parse_objects.c:	env->objects[0].pos.z = 6;
src/map_parse_objects.c:	env->objects[0].scale = 60;
src/map_parse_objects.c:	env->objects[0].sector = 0;
src/map_parse_objects.c:	env->objects[0].angle = -90;*/
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].floor = ft_atof(*line);
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_min = env->sectors[parser->sectors_count].floor;
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_max = env->sectors[parser->sectors_count].floor;
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_slope = ft_atof(*line);
src/map_parse_sectors.c:	if (env->sectors[parser->sectors_count].floor_slope > 45 || env->sectors[parser->sectors_count].floor_slope < -45)
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_slope = tan(env->sectors[parser->sectors_count].floor_slope * CONVERT_RADIANS);
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_texture = ft_atoi(*line);
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling = ft_atof(*line);
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_min = env->sectors[parser->sectors_count].ceiling;
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_max = env->sectors[parser->sectors_count].ceiling;
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_slope = ft_atof(*line);
src/map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling_slope > 45 || env->sectors[parser->sectors_count].ceiling_slope < -45)
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_slope = tan(env->sectors[parser->sectors_count].ceiling_slope * CONVERT_RADIANS);
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_texture = ft_atoi(*line);
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].nb_vertices = parser->sector_vertices_count;
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].vertices = (short*)malloc(sizeof(short) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].neighbors = (short*)malloc(sizeof(short) * (parser->sector_vertices_count))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].textures = (short*)malloc(sizeof(short) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].ceilings = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].floors = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_ceilings1 = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_floors1 = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_ceilings2 = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_floors2 = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].wall_width = (double*)malloc(sizeof(double) * (parser->sector_vertices_count + 1))))
src/map_parse_sectors.c:		env->sectors[parser->sectors_count].vertices[i] = ft_atoi(*line);
src/map_parse_sectors.c:		if (env->sectors[parser->sectors_count].vertices[i] < 0 || env->sectors[parser->sectors_count].vertices[i] >= env->nb_vertices)
src/map_parse_sectors.c:			return (ft_printf("Vertex \'%d\' in sector %d does not exist (line %d)\n", env->sectors[parser->sectors_count].vertices[i], parser->sectors_count, parser->line_count));
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].vertices[parser->sector_vertices_count] = env->sectors[parser->sectors_count].vertices[0];
src/map_parse_sectors.c:	if (check_vertices_uniqueness(env->sectors[parser->sectors_count]))
src/map_parse_sectors.c:	if (check_sector_duplicate(env, env->sectors[parser->sectors_count], parser->sectors_count))
src/map_parse_sectors.c:		env->sectors[parser->sectors_count].neighbors[i] = ft_atoi(*line);
src/map_parse_sectors.c:		if (env->sectors[parser->sectors_count].neighbors[i] < -1 || env->sectors[parser->sectors_count].neighbors[i] >= env->nb_sectors)
src/map_parse_sectors.c:			return (ft_printf("Neighbor \'%d\' in sector %d does not exist (line %d)\n", env->sectors[parser->sectors_count].neighbors[i], parser->sectors_count, parser->line_count));
src/map_parse_sectors.c:		if (env->sectors[parser->sectors_count].neighbors[i] == parser->sectors_count)
src/map_parse_sectors.c:		env->sectors[parser->sectors_count].textures[i] = ft_atoi(*line);
src/map_parse_sectors.c:		if (env->sectors[parser->sectors_count].textures[i] < 0 || env->sectors[parser->sectors_count].textures[i] >= MAX_TEXTURE)
src/map_parse_sectors.c:			return (ft_printf("Texture \'%d\' in sector %d does not exist (line %d)\n", env->sectors[parser->sectors_count].textures[i], parser->sectors_count, parser->line_count));
src/map_parse_sectors.c:	env->sectors[parser->sectors_count].num = parser->sectors_count;
src/map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling <= env->sectors[parser->sectors_count].floor)
src/map_parse_sectors.c:	while (parser->sectors_count < env->nb_sectors
src/map_parse_sectors.c:		else if (tmp[0] == '\0' && parser->sectors_count < env->nb_sectors)
src/map_parse_sectors.c:						env->nb_sectors - parser->sectors_count,
src/map_parse_sectors_utils.c:		current = env->sectors[i];
src/map_parse_sectors_utils.c:		if (sector_eq(sector, env->sectors[i]))
src/map_parse_vertices.c:		if (vertex.x == env->vertices[i].x && vertex.y == env->vertices[i].y)
src/map_parse_vertices.c:	env->vertices[parser->vertices_count].num = parser->vertices_count;
src/map_parse_vertices.c:	env->vertices[parser->vertices_count].y = ft_atof(line);
src/map_parse_vertices.c:	env->vertices[parser->vertices_count].x = ft_atof(line);
src/map_parse_vertices.c:	if (check_vertex_duplicate(env, env->vertices[parser->vertices_count],
src/map_parse_vertices.c:	while (parser->vertices_count < env->nb_vertices
src/map_parse_vertices.c:		else if (line[0] == '\0' && parser->vertices_count < env->nb_vertices)
src/map_parse_vertices.c:						env->nb_vertices - parser->vertices_count,
src/map_parser.c:			env->nb_vertices = ft_atoi(line);
src/map_parser.c:			if (env->nb_vertices < 3)
src/map_parser.c:			if (!(env->vertices = (t_vertex *)malloc(sizeof(t_vertex)
src/map_parser.c:							* (env->nb_vertices))))
src/map_parser.c:			env->nb_sectors = atoi(line);
src/map_parser.c:			if (env->nb_sectors < 1)
src/map_parser.c:			if (!(env->sectors = (t_sector *)malloc(sizeof(t_sector) * (env->nb_sectors))))
src/map_parser.c:			env->screen_sectors_size = ft_min(env->nb_sectors, env->w);
src/map_parser.c:			if (!(env->xmin = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
src/map_parser.c:			if (!(env->xmax = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
src/map_parser.c:			if (!(env->screen_sectors = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
src/map_parser.c:			if (!(env->screen_pos = (t_v2*)malloc(sizeof(t_v2) * (env->w))))
src/map_parser.c:			if (!(env->rendered_sectors = (short*)malloc(sizeof(short) * (env->screen_sectors_size))))
src/map_parser.c:			while (i < env->nb_sectors)
src/map_parser.c:				env->sectors[i].vertices = NULL;
src/map_parser.c:				env->sectors[i].ceilings = NULL;
src/map_parser.c:				env->sectors[i].floors = NULL;
src/map_parser.c:				env->sectors[i].clipped_ceilings1 = NULL;
src/map_parser.c:				env->sectors[i].clipped_floors1 = NULL;
src/map_parser.c:				env->sectors[i].clipped_ceilings2 = NULL;
src/map_parser.c:				env->sectors[i].clipped_floors2 = NULL;
src/map_parser.c:				env->sectors[i].neighbors = NULL;
src/map_parser.c:				env->sectors[i].x_max = -2147483648;
src/map_parser.c:				env->sectors[i].wall_width = NULL;
src/map_parser.c:				env->sectors[i].textures = NULL;
src/map_parser.c:	while (i < env->nb_sectors)
src/map_parser.c:		while (j < env->sectors[i].nb_vertices)
src/map_parser.c:			if (env->sectors[i].x_max < env->vertices[env->sectors[i].vertices[j]].x)
src/map_parser.c:				env->sectors[i].x_max = env->vertices[env->sectors[i].vertices[j]].x;
src/map_parser.c:			env->player.pos.y = ft_atof(line);
src/map_parser.c:			env->player.pos.x = ft_atof(line);
src/map_parser.c:			env->player.angle = ft_atof(line) * CONVERT_RADIANS;
src/map_parser.c:			env->player.angle_z = 0;
src/map_parser.c:			env->player.sector = ft_atoi(line);
src/map_parser.c:			if (env->player.sector < 0 || env->player.sector >= env->nb_sectors)
src/map_parser.c:	env->nb_sectors = 0;
src/map_parser.c:	env->nb_vertices = 0;
src/map_parser.c:	env->player.sector = -1;
src/map_parser.c:	if (env->player.sector == -1)
src/maths_utils.c:	sector = env->sectors[env->player.sector];
src/maths_utils.c:	v0 = env->vertices[sector.vertices[0]];
src/maths_utils.c:	env->player.pos.z =
src/maths_utils.c:		env->player.eyesight + sector.floor +
src/maths_utils.c:		(sector.normal.x * (env->player.pos.x - v0.x)
src/maths_utils.c:		 - sector.normal.y * (env->player.pos.y - v0.y)) * sector.floor_slope;
src/maths_utils.c:	sector = env->sectors[env->player.sector];
src/maths_utils.c:	v0 = env->vertices[sector.vertices[0]];
src/maths_utils.c:		env->player.eyesight + sector.floor +
src/maths_utils.c:		(sector.normal.x * (env->player.pos.x - v0.x)
src/maths_utils.c:		 - sector.normal.y * (env->player.pos.y - v0.y)) * sector.floor_slope;
src/maths_utils.c:	env->gravity.floor = player_feet;
src/menu.c:	while (xx < env->textures[i].surface->w && xx < env->w)
src/menu.c:		while (yy < env->textures[i].surface->h && yy < env->h)
src/menu.c:			if (env->textures[i].str[xx + env->textures[i].surface->w * yy] != 0xFFC10099)
src/menu.c:				env->sdl.texture_pixels[(x + (y * env->w)) + xx + env->w * yy] = env->textures[i].str[xx + env->textures[i].surface->w * yy];
src/menu.c:	env->button[ref_but].x = x;
src/menu.c:	env->button[ref_but].y = y;
src/menu.c:	env->button[ref_but].image = text;
src/menu.c:	env->button[ref_but].id = ref_but;
src/menu.c:	print_text(new_point(780, 850), new_printable_text("START", env->sdl.fonts.amazdoom70, 0xFFFFFFFF, 70), env);
src/minimap.c:	pixels = env->sdl.texture_pixels;
src/minimap.c:	if (x >= env->w - 300 && x < env->w && y >= 0 && y <= 300)
src/minimap.c:		if (color == 0xFFFF0000 || (pixels[x + env->w * y] != 0xFF00FF00
src/minimap.c:			&& pixels[x + env->w * y] != 0xFFFFFFF))
src/minimap.c:			if (x >= 0 && x < env->w && y >= 0 && y <= env->h)
src/minimap.c:				pixels[x + env->w * y] = color;
src/minimap.c:	start = new_point(env->w - 150, 150);
src/minimap.c:	x = env->w - 152;
src/minimap.c:	while (x < env->w - 147)
src/minimap.c:			(env->player.near_left.x - env->player.pos.x) * env->options.minimap_scale + start.x,
src/minimap.c:			(env->player.near_left.y - env->player.pos.y) * env->options.minimap_scale + 150,
src/minimap.c:			(env->player.angle_cos * env->camera.far_z - env->player.angle_sin * env->camera.far_left) * env->options.minimap_scale + start.x,
src/minimap.c:			(env->player.angle_sin * env->camera.far_z + env->player.angle_cos * env->camera.far_left) * env->options.minimap_scale + 150,
src/minimap.c:			(env->player.near_right.x - env->player.pos.x) * env->options.minimap_scale + start.x,
src/minimap.c:			(env->player.near_right.y - env->player.pos.y) * env->options.minimap_scale + 150,
src/minimap.c:	if (!env->options.test)
src/minimap.c:			(env->player.angle_cos * env->camera.far_z - env->player.angle_sin * env->camera.far_right) * env->options.minimap_scale + start.x,
src/minimap.c:			(env->player.angle_sin * env->camera.far_z + env->player.angle_cos * env->camera.far_right) * env->options.minimap_scale + 150,
src/minimap.c:	p0.x = env->player.angle_cos * env->camera.near_z * env->options.minimap_scale + start.x;
src/minimap.c:	p0.y = env->player.angle_sin * env->camera.near_z * env->options.minimap_scale + 150;
src/minimap.c:	p1.x = p0.x + env->player.perp_cos * env->w * env->options.minimap_scale;
src/minimap.c:	p1.y = p0.y + env->player.perp_sin * env->w * env->options.minimap_scale;
src/minimap.c:	p0.x = p0.x - env->player.perp_cos * env->w * env->options.minimap_scale;
src/minimap.c:	p0.y = p0.y - env->player.perp_sin * env->w * env->options.minimap_scale;
src/minimap.c:	if (env->options.test)
src/minimap.c:	p1.x = env->player.angle_cos * env->camera.near_z * env->options.minimap_scale + p0.x;
src/minimap.c:	p1.y = env->player.angle_sin * env->camera.near_z * env->options.minimap_scale + p0.y;
src/minimap.c:	max = env->w;
src/minimap.c:	if (sector.num == env->player.sector)
src/minimap.c:	start = new_point(env->w - 150, 150);
src/minimap.c:		pos.x += start.x + (env->vertices[sector.vertices[i]].x - env->player.pos.x) * env->options.minimap_scale;
src/minimap.c:		pos.y += start.y + (env->vertices[sector.vertices[i]].y - env->player.pos.y) * env->options.minimap_scale;
src/minimap.c:	if (pos.x > env->w - 297 && pos.x < env->w && pos.y <= 295 && pos.y >= 0)
src/minimap.c:					env->sdl.fonts.bebasneue,
src/minimap.c:	pixels = env->sdl.texture_pixels;
src/minimap.c:	while (i < env->nb_objects)
src/minimap.c:		object = env->objects[i];
src/minimap.c:		pos.x = env->w - 150 + (object.pos.x - env->player.pos.x) * env->options.minimap_scale;
src/minimap.c:			pos.y = 150 + (object.pos.y - env->player.pos.y) * env->options.minimap_scale;
src/minimap.c:				if (x > env->w - 300 && x < env->w && y >= 0 && y < 300)
src/minimap.c:					pixels[x + y * env->w] = 0xFFFF0000;
src/minimap.c:	start.x = env->w - 150;
src/minimap.c:	while (s < env->nb_sectors)
src/minimap.c:		sect = env->sectors[s];
src/minimap.c:		if (env->player.pos.z > sect.floor_min
src/minimap.c:				&& env->player.pos.z < sect.ceiling_max)
src/minimap.c:			if (s == env->player.sector)
src/minimap.c:				line.p0.x = start.x + (env->vertices[sect.vertices[v]].x - env->player.pos.x) * env->options.minimap_scale;
src/minimap.c:				line.p0.y = start.y + (env->vertices[sect.vertices[v]].y - env->player.pos.y) * env->options.minimap_scale;
src/minimap.c:				line.p1.x = start.x + (env->vertices[sect.vertices[v + 1]].x - env->player.pos.x) * env->options.minimap_scale;
src/minimap.c:				line.p1.y = start.y + (env->vertices[sect.vertices[v + 1]].y - env->player.pos.y) * env->options.minimap_scale;
src/movement.c:	if (is_in_sector(env, env->player.sector, p.x, p.y))
src/movement.c:		return (env->player.sector);
src/movement.c:	while (i < env->sectors[env->player.sector].nb_vertices)
src/movement.c:		if (env->sectors[env->player.sector].neighbors[i] >= 0)
src/movement.c:			if (is_in_sector(env, env->sectors[env->player.sector].neighbors[i], p.x, p.y))
src/movement.c:				return (env->sectors[env->player.sector].neighbors[i]);
src/movement.c:	while (i < env->nb_sectors)
src/movement.c:		if (is_in_sector(env, i, p.x, p.y) && env->player.pos.z > env->sectors[i].floor_min)
src/movement.c:	env->player.camera_x = env->player.pos.x + env->player.angle_cos * env->camera.near_z;
src/movement.c:	env->player.camera_y = env->player.pos.y + env->player.angle_sin * env->camera.near_z;
src/movement.c:	env->player.near_left.x = env->player.pos.x + (env->player.angle_cos * env->camera.near_z - env->player.angle_sin * env->camera.near_left);
src/movement.c:	env->player.near_left.y = env->player.pos.y + (env->player.angle_sin * env->camera.near_z + env->player.angle_cos * env->camera.near_left);
src/movement.c:	env->player.near_right.x = env->player.pos.x + (env->player.angle_cos * env->camera.near_z - env->player.angle_sin * env->camera.near_right);
src/movement.c:	env->player.near_right.y = env->player.pos.y + (env->player.angle_sin * env->camera.near_z + env->player.angle_cos * env->camera.near_right);
src/movement.c:	if (env->gravity.on_going)
src/movement.c:	if (((env->inputs.space && !env->player.state) || env->jump.on_going))
src/movement.c:	if (((env->inputs.ctrl && !env->player.state) || env->squat.on_going) && !env->jump.on_going)
src/movement.c:	tmp_speed = env->player.speed;
src/movement.c:	origin_pos = env->player.pos;
src/movement.c:	origin_sect = env->player.sector;
src/movement.c:	origin_camera_sect = env->player.camera_sector;
src/movement.c:	origin_right_sect = env->player.near_left_sector;
src/movement.c:	origin_left_sect = env->player.near_right_sector;
src/movement.c:	env->time.end = env->time.milli_s / 10;
src/movement.c:	if (env->time.end - env->time.start >= 1)
src/movement.c:		env->time.start = env->time.end;
src/movement.c:		if (env->inputs.forward && !env->inputs.backward)
src/movement.c:			if (check_collision(env, env->player.angle_cos * env->player.speed, env->player.angle_sin * env->player.speed) == 1)
src/movement.c:				env->player.pos.x += env->player.angle_cos * env->player.speed;
src/movement.c:				env->player.pos.y += env->player.angle_sin * env->player.speed;
src/movement.c:		else if (env->inputs.backward && !env->inputs.forward)
src/movement.c:			if (check_collision(env, env->player.angle_cos * -env->player.speed, env->player.angle_sin * -env->player.speed) == 1)
src/movement.c:				env->player.pos.x -= env->player.angle_cos * env->player.speed;
src/movement.c:				env->player.pos.y -= env->player.angle_sin * env->player.speed;
src/movement.c:		if (env->inputs.left && !env->inputs.right)
src/movement.c:			if (check_collision(env, env->player.angle_sin * env->player.speed, env->player.angle_cos * -env->player.speed) == 1)
src/movement.c:				env->player.pos.x += env->player.angle_sin * env->player.speed;
src/movement.c:				env->player.pos.y -= env->player.angle_cos * env->player.speed;
src/movement.c:		else if (env->inputs.right && !env->inputs.left)
src/movement.c:			if (check_collision(env, env->player.angle_sin * -env->player.speed, env->player.angle_cos * env->player.speed) == 1)
src/movement.c:				env->player.pos.x -= env->player.angle_sin * env->player.speed;
src/movement.c:				env->player.pos.y += env->player.angle_cos * env->player.speed;
src/movement.c:	env->player.speed = tmp_speed;
src/movement_collision.c:    motion.old_sector = env->player.sector;
src/movement_collision.c:    FUTURE_Z = env->player.eyesight + env->sectors[env->player.sector].floor + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].floor_slope;
src/movement_collision.c:    if (FUTURE_Z > env->sectors[env->player.sector].ceiling + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].ceiling_slope - 1)
src/movement_collision.c:    FUTURE_Z = env->player.eyesight + env->sectors[env->player.sector].floor + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].floor_slope;
src/movement_collision.c:    if (FUTURE_Z > env->player.pos.z + 2)
src/movement_collision.c:        end_pos = (env->sectors[env->player.sector].x_max + 1 - X1) * (Y2 - Y1) - (FUTURE_Y - Y1) * (X2 - X1);
src/movement_collision.c:    if (env->options.wall_lover == 1)
src/movement_collision.c:    env->player.pos.z = env->player.eyesight + env->sectors[env->player.sector].floor + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].floor_slope;
src/movement_collision.c:                env->player.speed = env->player.speed * 0.7;
src/movement_collision.c:            && diff_value(motion.wall_v1 , motion.wall_v2, env->vertices[env->sectors[env->player.sector].vertices[i]].num,  env->vertices[env->sectors[env->player.sector].vertices[i + 1]].num))
src/movement_collision.c:         && diff_value(motion.wall_v1, motion.wall_v2, env->vertices[env->sectors[env->player.sector].vertices[i]].num, env->vertices[env->sectors[env->player.sector].vertices[i + 1]].num))
src/movement_collision.c:            env->player.sector = NEIGHBOR;
src/movement_collision.c:            motion.wall_v1 = env->vertices[env->sectors[env->player.sector].vertices[i]].num;
src/movement_collision.c:            motion.wall_v2 = env->vertices[env->sectors[env->player.sector].vertices[i + 1]].num;
src/movement_collision.c:                env->player.sector = motion.old_sector;
src/movement_collision.c:        end_pos = (env->sectors[env->player.sector].x_max + 1 - X1) * (Y2 - Y1) - (FUTURE_Y - Y1) * (X2 - X1);
src/movement_collision.c:    if (env->options.wall_lover == 1)
src/movement_collision.c:    FUTURE_X = env->player.pos.x + x_move;
src/movement_collision.c:    FUTURE_Y = env->player.pos.y + y_move;
src/movement_collision.c:    while (i < env->sectors[env->player.sector].nb_vertices)
src/movement_collision.c:        motion.old_sector = env->player.sector;
src/movement_collision.c:                env->player.speed = env->player.speed * 0.7;
src/movement_collision.c:            motion.wall_v1 = env->vertices[env->sectors[env->player.sector].vertices[i]].num;
src/movement_collision.c:            motion.wall_v2 = env->vertices[env->sectors[env->player.sector].vertices[i + 1]].num;
src/movement_collision.c:            motion.old_z = env->player.pos.z;
src/movement_collision.c:            env->player.sector = NEIGHBOR;
src/movement_collision.c:                env->player.sector = motion.old_sector;
src/movement_collision.c:                env->player.pos.z = motion.old_z;
src/movement_collision.c:    while (i < env->sectors[sector].nb_vertices)
src/movement_collision.c:        end_pos = (env->sectors[sector].x_max + 1 - SECTOR_X1) * (SECTOR_Y2 - SECTOR_Y1) - (y - SECTOR_Y1) * (SECTOR_X2 - SECTOR_X1);
src/options.c:	env->screen_w[0] = 2560;
src/options.c:	env->screen_h[0] = 1440;
src/options.c:	env->screen_w[1] = 1920;
src/options.c:	env->screen_h[1] = 1080;
src/options.c:	env->screen_w[2] = 1600;
src/options.c:	env->screen_h[2] = 900;
src/options.c:	if (!(env->res = (char**)malloc(sizeof(char*) * 3)))
src/options.c:	if (!(env->res[0] = (char*)malloc(sizeof(char) * 11)))
src/options.c:	if (!(env->res[1] = (char*)malloc(sizeof(char) * 11)))
src/options.c:	if (!(env->res[2] = (char*)malloc(sizeof(char) * 10)))
src/options.c:	env->res[0] = "2560 x 1440";
src/options.c:	env->res[1] = "1920 x 1080";
src/options.c:	env->res[2] = "1600 x 900";
src/options.c:	env->w = env->screen_w[i];
src/options.c:	env->h = env->screen_h[i];
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_c)
src/options.c:		env->options.contouring = env->options.contouring ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_r)
src/options.c:		env->options.render_sectors = env->options.render_sectors ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_l)
src/options.c:		env->options.lighting = env->options.lighting ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_m)
src/options.c:		env->options.show_minimap = env->options.show_minimap ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_f)
src/options.c:		env->options.show_fps = env->options.show_fps ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_x)
src/options.c:		env->options.wall_lover = env->options.wall_lover ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_j)
src/options.c:		env->options.color_clipping = env->options.color_clipping ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_g)
src/options.c:		env->options.wall_color = env->options.wall_color ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_t)
src/options.c:		env->options.test = env->options.test ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_i)
src/options.c:		env->options.clipping = env->options.clipping ? 0 : 1;
src/options.c:	if (env->sdl.event.key.keysym.sym == SDLK_o)
src/options.c:		env->option = env->option ? 0 : 1;
src/options.c:		if (env->option)
src/options.c:	add_button(env, 30, env->w / 2 - 40, env->h / 2 - 200, 2);
src/options.c:	add_button(env, 31, env->w / 2 + 160, env->h / 2 - 200, 3);
src/options.c:	print_text(new_point(env->h / 2 - 200, env->w / 2 - 250), new_printable_text("Resolution :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
src/options.c:	print_text(new_point(env->h / 2 - 200 , env->w / 2 + 5), new_printable_text(env->res[env->i], env->sdl.fonts.alice30, 0x960018FF, 30), env);
src/options.c:	sound = ft_itoa(env->sound.g_music);
src/options.c:	add_button(env, 30, env->w / 2 - 40, env->h / 2 - 100, 4);
src/options.c:	add_button(env, 31, env->w / 2 + 160, env->h / 2 - 100, 5);
src/options.c:	print_text(new_point(env->h / 2 - 100 , env->w / 2 - 250), new_printable_text("Sound :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
src/options.c:	print_text(new_point(env->h / 2 - 100 , env->w / 2 + 65), new_printable_text(sound, env->sdl.fonts.alice30, 0x960018FF, 30), env);
src/options.c:	add_button(env, 0, env->w / 2 + 350, env->h / 2 + 350, 1);
src/options.c:	print_text(new_point(env->h / 4 - 100, env->w / 2 - 250), new_printable_text("PARAMETERS", env->sdl.fonts.alice70, 0x960018FF, 70), env);
src/options.c:	print_text(new_point(env->h / 2 + 350 , env->w / 2 + 350), new_printable_text("APPLIQUER", env->sdl.fonts.alice30, 0x960018FF, 30), env);
src/options.c:	if (env->aplicate_changes)
src/options.c:		init_screen_size(env, env->i);
src/options.c:		env->aplicate_changes = 0;
src/physics.c:	new_time = env->time.milli_s;
src/physics.c:	env->time.milli_s = SDL_GetTicks();
src/physics.c:	env->player.speed = ((env->time.milli_s - new_time) / 1000) * 15;
src/physics.c:	env->player.rotation_speed = ((env->time.milli_s - new_time) / 1000) * 0.2;
src/physics.c:	env->time.tenth_s = env->time.milli_s / 100;
src/physics.c:	//env->time.tick = 1000 / env->fps;
src/physics.c:	env->gravity.on_going = 0;
src/physics.c:	new_time = env->time.milli_s;
src/physics.c:	if (!env->jump.on_going)
src/physics.c:		//Mix_PlayChannel(1, env->sound.jump, 0);
src/physics.c:		env->jump.on_going = env->time.tenth_s;
src/physics.c:	if (env->jump.nb_frame > 0)
src/physics.c:		if (new_time >= env->jump.start + 10)
src/physics.c:			env->jump.start = new_time;
src/physics.c:			env->player.pos.z += (x * env->gravity.weight);
src/physics.c:			env->gravity.weight -= 0.05;
src/physics.c:			env->jump.nb_frame--;
src/physics.c:			if (env->gravity.weight < 0)
src/physics.c:				env->gravity.weight = 0;
src/physics.c:	if (env->jump.nb_frame == 0/*env->jump.start - env->jump.on_going  >= env->jump.end*/)
src/physics.c:		env->gravity.weight = 1;
src/physics.c:		env->gravity.on_going = 1;
src/physics.c:		env->jump.start = 0;
src/physics.c:		env->jump.nb_frame = 15;
src/physics.c:		env->jump.on_going = 0;
src/physics.c:	if (env->player.pos.z + x > env->gravity.floor)
src/physics.c:		x = env->gravity.floor - env->player.pos.z;
src/physics.c:		env->player.pos.z += x;
src/physics.c:	if (env->player.pos.z < env->gravity.floor)
src/physics.c:		env->player.pos.z += (x);
src/physics.c:	if (env->player.pos.z + (x) > env->gravity.floor)
src/physics.c:		x = env->gravity.floor - env->player.pos.z;
src/physics.c:		env->player.pos.z += x;
src/physics.c:	env->gravity.start = env->time.tenth_s;
src/physics.c:	env->player.state = 1;
src/physics.c:	if (env->gravity.start - env->gravity.end >= 0.1)
src/physics.c:		env->gravity.end = env->gravity.start;
src/physics.c:		if (env->player.pos.z > env->gravity.floor && env->player.pos.z -
src/physics.c:				(x * env->gravity.weight) < env->gravity.floor)
src/physics.c:			x = env->player.pos.z - env->gravity.floor;
src/physics.c:			env->player.pos.z -= x;
src/physics.c:			env->gravity.weight = 1;
src/physics.c:			env->player.state = 0;
src/physics.c:		if (env->player.pos.z > env->gravity.floor)
src/physics.c:			env->player.pos.z -= (x * env->gravity.weight);
src/physics.c:			env->gravity.weight += 0.1;
src/physics.c:		if ((env->player.pos.z > env->gravity.floor && env->player.pos.z -
src/physics.c:					(x * env->gravity.weight) < env->gravity.floor) || env->player.pos.z == env->gravity.floor)
src/physics.c:			x = env->player.pos.z - env->gravity.floor;
src/physics.c:			env->player.pos.z -= x;
src/physics.c:			env->gravity.weight = 1;
src/physics.c:			env->player.state = 0;
src/physics.c:	env->squat.on_going = 1;
src/physics.c:	if (env->squat.end != env->time.tenth_s)
src/physics.c:		env->squat.start = env->squat.end;
src/physics.c:	env->squat.end = env->time.tenth_s;
src/physics.c:	if (env->player.eyesight > 3)
src/physics.c:		env->player.pos.z -= 0.5;
src/physics.c:		env->player.eyesight -= 0.5;
src/physics.c:	if (env->player.eyesight == 3 && !env->inputs.ctrl)
src/physics.c:		env->player.eyesight = 6;
src/physics.c:		env->player.state = 0;
src/physics.c:		env->squat.on_going = 0;
src/physics.c:	double	p_z = env->player.pos.z;
src/physics.c:	if (p_z != env->gravity.floor)
src/physics.c:		if (p_z > env->gravity.floor && !env->jump.on_going)
src/physics.c:			env->flag = 1;
src/physics.c:		if (env->player.pos.z < env->gravity.floor && !env->jump.on_going && !env->player.state)
src/print_debug.c:	h = env->h;
src/print_debug.c:	player_sector = ft_sitoa(env->player.sector);
src/print_debug.c:	left_sector = ft_sitoa(env->player.near_left_sector);
src/print_debug.c:	right_sector = ft_sitoa(env->player.near_right_sector);
src/print_debug.c:	print_text(new_point(h - 150, 5), new_printable_text("Player sector = ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	print_text(new_point(h - 150, 215), new_printable_text(player_sector, env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	print_text(new_point(h - 100, 5), new_printable_text("Near_left sector = ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	print_text(new_point(h - 50, 5), new_printable_text("Near_right sector = ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	print_text(new_point(h - 100, 255), new_printable_text(left_sector, env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	print_text(new_point(h - 50, 275), new_printable_text(right_sector, env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	print_text(new_point(0, 1300), new_printable_text("Test", env->sdl.fonts.alice30, 0xFFFFFFFF, 20), env);
src/print_debug.c:	print_text(new_point(h - 200, 5), new_printable_text("Clipping :", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
src/print_debug.c:	if (env->options.clipping)
src/print_debug.c:		print_text(new_point(h - 200, 145), new_printable_text("ON", env->sdl.fonts.alice30, 0x00FF00FF, 30), env);
src/print_debug.c:		print_text(new_point(h - 200, 145), new_printable_text("OFF", env->sdl.fonts.alice30, 0xFF0000FF, 30), env);
src/render.c:	if (!env->rendered_sectors[render.sector])
src/render.c:		env->rendered_sectors[render.sector]++;
src/render.c:		sector = env->sectors[render.sector];
src/render.c:				//|| !env->options.clipping)
src/render.c:					env->vertices[sector.vertices[i]].clipped_x[0] = (render.clipped_vx1) * env->player.angle_sin
src/render.c:						+ (render.clipped_vz1) * env->player.angle_cos;
src/render.c:					env->vertices[sector.vertices[i]].clipped_y[0] = (render.clipped_vx1) * -env->player.angle_cos
src/render.c:						+ (render.clipped_vz1) * env->player.angle_sin;
src/render.c:					env->vertices[sector.vertices[i]].clipped_x[0] += env->player.pos.x;
src/render.c:					env->vertices[sector.vertices[i]].clipped_y[0] += env->player.pos.y;
src/render.c:					env->vertices[sector.vertices[i]].clipped[0] = 1;
src/render.c:					line.p0.x = env->w - 150 + (env->vertices[sector.vertices[i]].clipped_x[0] - env->player.pos.x) * env->options.minimap_scale;
src/render.c:					line.p0.y = 150 + (env->vertices[sector.vertices[i]].clipped_y[0] - env->player.pos.y) * env->options.minimap_scale;
src/render.c:						env->sectors[render.sector].clipped_floors1[i] = get_clipped_floor(0, sector, env->vertices[sector.vertices[i]], env); 
src/render.c:						env->sectors[render.sector].clipped_ceilings1[i] = get_clipped_ceiling(0, sector, env->vertices[sector.vertices[i]], env); 
src/render.c:					line.p0.x = env->w - 150 + (env->vertices[sector.vertices[i]].x - env->player.pos.x) * env->options.minimap_scale;
src/render.c:					line.p0.y = 150 + (env->vertices[sector.vertices[i]].y - env->player.pos.y) * env->options.minimap_scale;
src/render.c:					env->vertices[sector.vertices[i + 1]].clipped_x[1] = (render.clipped_vx2) * env->player.angle_sin
src/render.c:						+ (render.clipped_vz2) * env->player.angle_cos;
src/render.c:					env->vertices[sector.vertices[i + 1]].clipped_y[1] = (render.clipped_vx2) * -env->player.angle_cos
src/render.c:						+ (render.clipped_vz2) * env->player.angle_sin;
src/render.c:					env->vertices[sector.vertices[i + 1]].clipped_x[1] += env->player.pos.x;
src/render.c:					env->vertices[sector.vertices[i + 1]].clipped_y[1] += env->player.pos.y;
src/render.c:					env->vertices[sector.vertices[i + 1]].clipped[1] = 1;
src/render.c:					line.p1.x = env->w - 150 + (env->vertices[sector.vertices[i + 1]].clipped_x[1] - env->player.pos.x) * env->options.minimap_scale;
src/render.c:					line.p1.y = 150 + (env->vertices[sector.vertices[i + 1]].clipped_y[1] - env->player.pos.y) * env->options.minimap_scale;
src/render.c:						env->sectors[render.sector].clipped_floors2[i + 1] = get_clipped_floor(1, sector, env->vertices[sector.vertices[i + 1]], env); 
src/render.c:						env->sectors[render.sector].clipped_ceilings2[i + 1] = get_clipped_ceiling(1, sector, env->vertices[sector.vertices[i + 1]], env); 
src/render.c:					line.p1.x = env->w - 150 + (env->vertices[sector.vertices[i + 1]].x - env->player.pos.x) * env->options.minimap_scale;
src/render.c:					line.p1.y = 150 + (env->vertices[sector.vertices[i + 1]].y - env->player.pos.y) * env->options.minimap_scale;
src/render.c:				if (env->options.test && env->player.pos.z > sector.floor_min && env->player.pos.z < sector.ceiling_max)
src/render.c:					if (sector.neighbors[i] >= 0 && sector.neighbors[i] != env->player.sector)
src/render.c:						render.nv1 = get_vertex_nb_in_sector(sector.vertices[i], env->sectors[sector.neighbors[i]]);
src/render.c:						render.nv2 = get_vertex_nb_in_sector(sector.vertices[i + 1], env->sectors[sector.neighbors[i]]);
src/render.c:						project_neighbor_floor_and_ceiling(&render, env, env->sectors[sector.neighbors[i]]);
src/render.c:						if (env->options.render_sectors)
src/render.c:						render.texel.x = ((1.0 - render.alpha) * env->vertices[sector.vertices[i]].x / render.vz1 + render.alpha * env->vertices[sector.vertices[i + 1]].x / render.vz2) * render.z;
src/render.c:						render.texel.y = ((1.0 - render.alpha) * env->vertices[sector.vertices[i]].y / render.vz1 + render.alpha * env->vertices[sector.vertices[i + 1]].y / render.vz2) * render.z;
src/render.c:						render.distfloor = ((env->h / 2.0) / (double)(render.max_floor - render.floor_horizon));
src/render.c:						render.distceiling = ((env->h / 2.0) / (double)(render.max_ceiling - render.ceiling_horizon));
src/render.c:							if (!env->options.render_sectors)
src/render.c:								if (env->options.lighting)
src/render.c:								if (env->options.contouring && (x == render.x1 || x == render.x2))
src/render.c:										sector.clipped_floors1[i], env->sectors[sector.neighbors[i]].clipped_floors2[render.nv2]);
src/render.c:							//if (render.z < env->depth_array[x])
src/render.c:							//if (env->depth_array[x] > render.light)
src/render.c:								//env->depth_array[x] = render.light;
src/render.c:								//env->depth_array[x] = render.z;
src/render.c:								if (env->options.color_clipping && (render.v1_clipped || render.v2_clipped))
src/render.c:								if (env->options.wall_color)
src/render.c:								if (env->options.lighting)
src/render.c:								if (env->options.contouring && (x == render.x1 || x == render.x2))
src/render.c:							vline.end = env->h - 1;
src/render.c:		env->rendered_sectors[render.sector]--;
src/render.c:	max = env->screen_sectors_size;
src/render.c:		env->xmin[i] = -1;
src/render.c:		env->xmax[i] = -1;
src/render.c:		env->screen_sectors[i] = -1;
src/render.c:	while (i < env->nb_sectors)
src/render.c:		env->rendered_sectors[i] = 0;
src/render.c:	while (i < env->w)
src/render.c:		env->depth_array[i] = 999999999999999;
src/render.c:	render.ymin = ft_max(env->h / 2 + env->camera.y1 * env->camera.scale, 0);
src/render.c:	render.ymax = ft_min(env->h / 2 + env->camera.y2 * env->camera.scale, env->h - 1);
src/render.c:		render.xmin = env->xmin[i];
src/render.c:		render.xmax = env->xmax[i];
src/render.c:		render.sector = env->screen_sectors[i];
src/render_maths.c:		render->v1.x = env->vertices[sector.vertices[i]].x - env->player.pos.x;
src/render_maths.c:		render->v1.z = env->vertices[sector.vertices[i]].y - env->player.pos.y;
src/render_maths.c:	render->v2.x = env->vertices[sector.vertices[i + 1]].x - env->player.pos.x;
src/render_maths.c:	render->v2.z = env->vertices[sector.vertices[i + 1]].y - env->player.pos.y;
src/render_maths.c:		render->vx1 = render->v1.x * env->player.angle_sin - render->v1.z * env->player.angle_cos;
src/render_maths.c:		render->vz1 = render->v1.x * env->player.angle_cos + render->v1.z * env->player.angle_sin;
src/render_maths.c:	render->vx2 = render->v2.x * env->player.angle_sin - render->v2.z * env->player.angle_cos;
src/render_maths.c:	render->vz2 = render->v2.x * env->player.angle_cos + render->v2.z * env->player.angle_sin;
src/render_maths.c:	y1 = sector.clipped_floors1[i] - env->player.pos.z;
src/render_maths.c:	y2 = sector.clipped_floors2[i + 1] - env->player.pos.z;
src/render_maths.c:	render->vfy1 = y1 + (render->vz1 * env->player.angle_z);
src/render_maths.c:	render->vfy2 = y2 + (render->vz2 * env->player.angle_z);
src/render_maths.c:	y1 = sector.clipped_ceilings1[i] - env->player.pos.z;
src/render_maths.c:	y2 = sector.clipped_ceilings2[i + 1] - env->player.pos.z;
src/render_maths.c:	render->vcy1 = y1 + (render->vz1 * env->player.angle_z);
src/render_maths.c:	render->vcy2 = y2 + (render->vz2 * env->player.angle_z);
src/render_maths.c:	y1 = sector.clipped_floors1[i] - env->player.pos.z;
src/render_maths.c:	y2 = sector.clipped_floors2[i + 1] - env->player.pos.z;
src/render_maths.c:	render->vfy1 = y1 + (render->clipped_vz1 * env->player.angle_z);
src/render_maths.c:	render->vfy2 = y2 + (render->clipped_vz2 * env->player.angle_z);
src/render_maths.c:	/*render->vfy1 = y1 * env->player.angle_z_cos + render->vz1 * env->player.angle_z_sin;
src/render_maths.c:	render->vfy2 = y2 * env->player.angle_z_cos + render->vz2 * env->player.angle_z_sin;*/
src/render_maths.c:	y1 = sector.clipped_ceilings1[i] - env->player.pos.z;
src/render_maths.c:	y2 = sector.clipped_ceilings2[i + 1] - env->player.pos.z;
src/render_maths.c:	render->vcy1 = y1 + (render->clipped_vz1 * env->player.angle_z);
src/render_maths.c:	render->vcy2 = y2 + (render->clipped_vz2 * env->player.angle_z);
src/render_maths.c:	/*render->vcy1 = y1 * env->player.angle_z_cos + render->vz1 * env->player.angle_z_sin;
src/render_maths.c:	render->vcy2 = y2 * env->player.angle_z_cos + render->vz2 * env->player.angle_z_sin;*/
src/render_maths.c:	y1 = sector.floors[i] - env->player.pos.z;
src/render_maths.c:	y2 = sector.floors[i + 1] - env->player.pos.z;
src/render_maths.c:	render->vfy1 = y1 + (render->vz1 * env->player.angle_z);
src/render_maths.c:	render->vfy2 = y2 + (render->vz2 * env->player.angle_z);
src/render_maths.c:	/*render->vfy1 = y1 * env->player.angle_z_cos + render->vz1 * env->player.angle_z_sin;
src/render_maths.c:	render->vfy2 = y2 * env->player.angle_z_cos + render->vz2 * env->player.angle_z_sin;*/
src/render_maths.c:	y1 = sector.ceilings[i] - env->player.pos.z;
src/render_maths.c:	y2 = sector.ceilings[i + 1] - env->player.pos.z;
src/render_maths.c:	render->vcy1 = y1 + (render->vz1 * env->player.angle_z);
src/render_maths.c:	render->vcy2 = y2 + (render->vz2 * env->player.angle_z);
src/render_maths.c:	/*render->vcy1 = y1 * env->player.angle_z_cos + render->vz1 * env->player.angle_z_sin;
src/render_maths.c:	render->vcy2 = y2 * env->player.angle_z_cos + render->vz2 * env->player.angle_z_sin;*/
src/render_maths.c:	y1 = neighbor.clipped_floors1[render->nv1] - env->player.pos.z;
src/render_maths.c:	y2 = neighbor.clipped_floors2[render->nv2] - env->player.pos.z;
src/render_maths.c:	render->nvfy1 = y1 + (render->clipped_vz1 * env->player.angle_z);
src/render_maths.c:	render->nvfy2 = y2 + (render->clipped_vz2 * env->player.angle_z);
src/render_maths.c:	/*render->nvfy1 = y1 * env->player.angle_z_cos + render->vz1 * env->player.angle_z_sin;
src/render_maths.c:	render->nvfy2 = y2 * env->player.angle_z_cos + render->vz2 * env->player.angle_z_sin;*/
src/render_maths.c:	y1 = neighbor.clipped_ceilings1[render->nv1] - env->player.pos.z;
src/render_maths.c:	y2 = neighbor.clipped_ceilings2[render->nv2] - env->player.pos.z;
src/render_maths.c:	render->nvcy1 = y1 + (render->clipped_vz1 * env->player.angle_z);
src/render_maths.c:	render->nvcy2 = y2 + (render->clipped_vz2 * env->player.angle_z);
src/render_maths.c:	/*render->nvcy1 = y1 * env->player.angle_z_cos + render->vz1 * env->player.angle_z_sin;
src/render_maths.c:	render->nvcy2 = y2 * env->player.angle_z_cos + render->vz2 * env->player.angle_z_sin;*/
src/render_maths.c:	scale = env->camera.scale;
src/render_maths.c:	render->floor1 = env->h / 2 +
src/render_maths.c:	render->floor2 = env->h / 2 +
src/render_maths.c:	render->ceiling1 = env->h / 2 +
src/render_maths.c:	render->ceiling2 = env->h / 2 +
src/render_maths.c:	render->x1 = env->w / 2 + (int)(render->clipped_vx1 * (scale / -render->clipped_vz1));
src/render_maths.c:	render->x2 = env->w / 2 + (int)(render->clipped_vx2 * (scale / -render->clipped_vz2));
src/render_maths.c:	scale = env->camera.scale;
src/render_maths.c:	render->neighbor_floor1 = env->h / 2 +
src/render_maths.c:	render->neighbor_floor2 = env->h / 2 +
src/render_maths.c:	render->neighbor_ceiling1 = env->h / 2 +
src/render_maths.c:	render->neighbor_ceiling2 = env->h / 2 +
src/render_maths.c:	scale = env->camera.scale;
src/render_maths.c:	render->preclip_floor1 = env->h / 2 +
src/render_maths.c:	render->preclip_floor2 = env->h / 2 +
src/render_maths.c:	render->preclip_ceiling1 = env->h / 2 +
src/render_maths.c:	render->preclip_ceiling2 = env->h / 2 +
src/render_maths.c:	render->preclip_x1 = env->w / 2 + (int)(render->vx1 * (scale / -render->vz1));
src/render_maths.c:	render->preclip_x2 = env->w / 2 + (int)(render->vx2 * (scale / -render->vz2));
src/screen_utils.c:	if (SDL_UpdateTexture(env->sdl.texture, NULL, env->sdl.texture_pixels, env->w * sizeof(Uint32)))
src/screen_utils.c:	//if (SDL_UpdateTexture(env->sdl.texture, NULL, env->depth_array, env->w * sizeof(Uint32)))
src/screen_utils.c:	SDL_RenderCopy(env->sdl.renderer, env->sdl.texture, NULL, NULL);
src/screen_utils.c:	SDL_RenderPresent(env->sdl.renderer);
src/screen_utils.c:	texture_pixels = env->sdl.texture_pixels;
src/screen_utils.c:					&& pos.y + x >= 0 && pos.y + x < env->w && pos.x + y >= 0 && pos.x + y < env->h)
src/screen_utils.c:			texture_pixels[pos.y + x + env->w * (pos.x + y)] =
src/screen_utils.c:	pixels = env->sdl.texture_pixels;
src/screen_utils.c:	max = env->h;
src/screen_utils.c:		//env->sdl.img_str[i * env->w + env->w / 2] = 0xFFFFFFFF;
src/screen_utils.c:		pixels[i * env->w + env->w / 2] = 0xFFFFFFFF;
src/screen_utils.c:	max = env->w;
src/screen_utils.c:		//env->sdl.img_str[env->h / 2 * env->w + i] = 0xFFFFFFFF;
src/screen_utils.c:		pixels[env->h / 2 * env->w + i] = 0xFFFFFFFF;
src/screen_utils.c:	pixels = env->sdl.texture_pixels;
src/screen_utils.c:	x = env->w / 2;
src/screen_utils.c:	y = env->h / 2 - 10;
src/screen_utils.c:	max = env->h / 2 - 2;
src/screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
src/screen_utils.c:	y = env->h / 2 + 10;
src/screen_utils.c:	max = env->h / 2 + 2;
src/screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
src/screen_utils.c:	y = env->h / 2;
src/screen_utils.c:	x = env->w / 2 - 10;
src/screen_utils.c:	max = env->w / 2 - 2;
src/screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
src/screen_utils.c:	x = env->w / 2 + 10;
src/screen_utils.c:	max = env->w / 2 + 2;
src/screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
src/sprites_maths.c:		- env->player.pos.x;
src/sprites_maths.c:	object->translated_left_bottom.z = object.pos.y - env->player.pos.y;
src/sprites_maths.c:	object->translated_left_bottom.y = (object.pos.z - env->player.pos.z);
src/sprites_maths.c:		- env->player.pos.x;
src/sprites_maths.c:		- env->player.pos.z;
src/sprites_maths.c:	object->translated_pos.x = object->pos.x - env->player.pos.x;
src/sprites_maths.c:	object->translated_pos.z = object->pos.y - env->player.pos.y;
src/sprites_maths.c:	object->translated_pos.y = object->pos.z - env->player.pos.z;
src/sprites_maths.c:		* env->player.angle_sin - object->translated_left_bottom.z
src/sprites_maths.c:		* env->player.angle_cos;
src/sprites_maths.c:		* env->player.angle_cos + object->translated_left_bottom.z
src/sprites_maths.c:		* env->player.angle_sin;
src/sprites_maths.c:		+ object->rotated_left_bottom.z * env->player.angle_z;
src/sprites_maths.c:		* env->player.angle_sin - object->translated_right_bottom.z
src/sprites_maths.c:		* env->player.angle_cos;
src/sprites_maths.c:		+ object->rotated_left_bottom.z * env->player.angle_z;
src/sprites_maths.c:		* env->player.angle_sin - object->translated_pos.z * env->player.angle_cos;
src/sprites_maths.c:		* env->player.angle_cos + object->translated_pos.z * env->player.angle_sin;
src/sprites_maths.c:		+ object->rotated_pos.z * env->player.angle_z;
src/sprites_maths.c:	scale = env->camera.scale;
src/sprites_maths.c:	orender->screen_pos.y = env->h / 2
src/sprites_maths.c:	orender->screen_pos.x = env->w / 2 + (object.rotated_pos.x * (scale / -object.rotated_pos.z));
src/sprites_maths.c:	orender->dist = sqrt(pow(object.pos.x - env->player.pos.x, 2)
src/sprites_maths.c:		+ pow(object.pos.y - env->player.pos.y, 2));
src/valid_map.c:	while (i < env->nb_sectors)
src/valid_map.c:	vertex = env->vertices[0];
src/valid_map.c:		vertex = env->vertices[sector.vertices[i]];
src/valid_map.c:	while (i < env->nb_sectors)
src/valid_map.c:		if (check_sector(env->sectors[i], env))
src/valid_map.c:	while (i < env->nb_vertices)
src/view.c:	angle = env->player.angle;
src/view.c:	angle_cos = env->player.angle_cos;
src/view.c:	angle_sin = env->player.angle_sin;
src/view.c:	origin_camera_sect = env->player.camera_sector;
src/view.c:	origin_right_sect = env->player.near_left_sector;
src/view.c:	origin_left_sect = env->player.near_right_sector;
src/view.c:	env->player.angle += env->sdl.mouse_x * env->player.rotation_speed;
src/view.c:	env->player.angle_cos = cos(env->player.angle);
src/view.c:	env->player.angle_sin = sin(env->player.angle);
src/view.c:	env->player.perp_cos = cos(env->player.angle - M_PI / 2);
src/view.c:	env->player.perp_sin = sin(env->player.angle - M_PI / 2);
src/view.c:	/*env->player.camera_sector = get_sector(env, new_v2(env->player.camera_x, env->player.camera_y));
src/view.c:	env->player.near_left_sector = get_sector(env, new_v2(env->player.near_left.x, env->player.near_left.y));
src/view.c:	env->player.near_right_sector = get_sector(env, new_v2(env->player.near_right.x, env->player.near_right.y));
src/view.c:	if (env->player.near_left_sector == -1 || env->player.near_right_sector == -1)
src/view.c:		env->player.angle = angle;
src/view.c:		env->player.angle_cos = angle_cos;
src/view.c:		env->player.angle_sin = angle_sin;
src/view.c:		env->player.camera_sector = origin_camera_sect;
src/view.c:		env->player.near_left_sector = origin_left_sect;
src/view.c:		env->player.near_right_sector = origin_right_sect;
src/view.c:	env->player.angle_z = ft_fclamp(env->player.angle_z + env->sdl.mouse_y * 0.005, -5, 5);
src/view.c:	env->player.angle_z_cos = cos(env->player.angle_z);
src/view.c:	env->player.angle_z_sin = sin(env->player.angle_z);
src/weapons.c:	pixels = env->sdl.texture_pixels;
src/weapons.c:	texture_pixels = env->textures[sprite].str;
src/weapons.c:	texture_w = env->textures[sprite].surface->w;
src/weapons.c:	texture_h = env->textures[sprite].surface->h;
src/weapons.c:    window_w = (int)(env->w - texture_w) / 1.5;
src/weapons.c:    window_h = (env->h - texture_h) + env->weapons[0].weapon_switch;
src/weapons.c:        while (y < texture_h  && (window_h + y) < env->h)
src/weapons.c:                pixels[(window_w + x) + env->w * (window_h + y)] = 
src/weapons.c:    if (env->shot.start == 0)
src/weapons.c:        env->shot.on_going = 1;
src/weapons.c:		env->shot.start = SDL_GetTicks();
src/weapons.c:        if (env->weapons[nb].ammo <= 0)
src/weapons.c:            env->weapons[nb].no_ammo = 1;
src/weapons.c:			Mix_PlayChannel(2, env->weapons[nb].empty, 0);
src/weapons.c:            env->weapons[nb].no_ammo = 0;
src/weapons.c:            Mix_PlayChannel(2, env->weapons[nb].sound, 0);
src/weapons.c:            env->weapons[nb].ammo--;
src/weapons.c:    if (!env->weapons[nb].no_ammo)
src/weapons.c:        if (env->time.milli_s > env->shot.start + 70 && ((env->time.milli_s - env->shot.start) / 70 < env->weapons[nb].nb_sprites))
src/weapons.c:            draw_weapon(env, env->weapons[nb].first_sprite + (int)((env->time.milli_s - env->shot.start) / 70));
src/weapons.c:            draw_weapon(env, env->weapons[nb].first_sprite);
src/weapons.c:        draw_weapon(env, env->weapons[nb].first_sprite);
src/weapons.c:    if ((int)((env->time.milli_s - env->shot.start)) >= env->weapons[nb].nb_sprites * 70)
src/weapons.c:        env->shot.start = 0;
src/weapons.c:        env->shot.on_going = 0;
src/weapons.c:    if (env->weapon_change.start == 0)
src/weapons.c:        env->weapon_change.start = SDL_GetTicks();
src/weapons.c:        env->weapon_change.on_going = 1;
src/weapons.c:    time_spent = env->time.milli_s - env->weapon_change.start;
src/weapons.c:        env->weapons[0].weapon_switch  = 75 * (int)(time_spent / 70);
src/weapons.c:        if (env->sdl.event.wheel.y > 0)
src/weapons.c:		    env->player.curr_weapon = (env->player.curr_weapon >= NB_WEAPONS - 1 ? 0 : env->player.curr_weapon + 1);
src/weapons.c:	    else if (env->sdl.event.wheel.y < 0)
src/weapons.c:	        env->player.curr_weapon = (env->player.curr_weapon <= 0 ? NB_WEAPONS - 1 : env->player.curr_weapon - 1);
src/weapons.c:        env->weapons[0].weapon_switch = 0;
src/weapons.c:        env->weapon_change.start = 0;
src/weapons.c:        env->weapon_change.on_going = 0;
src/weapons.c:    print_text(new_point(env->h - env->h / 15, env->w / 4), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xFFFFFF00, 0), env);
src/weapons.c:    str = ft_itoa(env->weapons[env->player.curr_weapon].ammo);
src/weapons.c:    print_text(new_point(env->h - env->h / 15, env->w / 4 + 110), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xFFFFFF00, 0), env);
src/weapons.c:    print_text(new_point(env->h - env->h / 15, env->w / 4 + 160), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xFFFFFF00, 0), env);
src/weapons.c:    str = ft_itoa(env->weapons[env->player.curr_weapon].max_ammo);
src/weapons.c:    print_text(new_point(env->h - env->h / 15, env->w / 4 + 180), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xFFFFFF00, 0), env);
