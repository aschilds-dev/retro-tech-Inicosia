add_object.c:	object.num = env->nb_objects;
add_object.c:	object.pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
add_object.c:	object.pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
add_object.c:		object.light = env->sectors[object.sector].light;
add_object.c:	if (!(env->objects = (t_object*)ft_realloc(env->objects, sizeof(t_object) * env->nb_objects, sizeof(t_object) * (env->nb_objects + 1))))
add_object.c:	env->objects[env->nb_objects] = object;
add_player.c:	env->player.pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
add_player.c:	env->player.pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
add_player.c:	env->player.pos.z = 0;
add_player.c:	env->player.angle = 0;
add_player.c:	env->player.angle_z = 0;
add_player.c:	env->player.eyesight = 6;
add_player.c:	env->player.speed = 0.5;
add_player.c:	env->player.angle_cos = cos(env->player.angle);
add_player.c:	env->player.angle_cos = sin(env->player.angle);
add_player.c:	env->player.perp_cos = cos(env->player.angle - M_PI / 2);
add_player.c:	env->player.perp_sin = sin(env->player.angle - M_PI / 2);
add_player.c:	env->player.sector = get_sector_no_z(env,
add_player.c:			env->player.pos);
add_player.c:	if (env->player.sector != -1)
add_sector.c:	tmp = env->editor.current_vertices;
add_sector.c:	sector.num = env->nb_sectors;
add_sector.c:	if (!(env->sectors = (t_sector*)ft_realloc(env->sectors,
add_sector.c:					sizeof(t_sector) * env->nb_sectors,
add_sector.c:					sizeof(t_sector) * (env->nb_sectors + 1))))
add_sector.c:	env->sectors[env->nb_sectors] = sector;
add_sector.c:	env->nb_sectors++;
add_vertex.c:	if (!env->editor.current_vertices)
add_vertex.c:	if (!env->editor.current_vertices->next)
add_vertex.c:		v = (t_vertex*)env->editor.current_vertices->content;
add_vertex.c:		free(env->editor.current_vertices);
add_vertex.c:		env->editor.current_vertices = NULL;
add_vertex.c:		env->editor.start_vertex = -1;
add_vertex.c:	tmp = env->editor.current_vertices;
add_vertex.c:	while (env->editor.current_vertices)
add_vertex.c:		tmp = env->editor.current_vertices;
add_vertex.c:		env->editor.current_vertices = env->editor.current_vertices->next;
add_vertex.c:	if (!(new = ft_lstnew(&env->vertices[num], sizeof(t_vertex))))
add_vertex.c:	ft_lstpushback(&env->editor.current_vertices, new);
add_vertex.c:	vertex.num = env->nb_vertices;
add_vertex.c:	vertex.x = round((env->sdl.mx - env->editor.center.x) / env->editor.scale);
add_vertex.c:	vertex.y = round((env->sdl.my - env->editor.center.y) / env->editor.scale);
add_vertex.c:	if (!(env->vertices = (t_vertex*)ft_realloc(env->vertices, sizeof(t_vertex) * env->nb_vertices, sizeof(t_vertex) * (env->nb_vertices + 1))))
add_vertex.c:	env->vertices[env->nb_vertices] = vertex;
add_vertex.c:	env->nb_vertices++;
bmp_parse_pixel_data.c:			env->textures[index].str[x + y * parser->w] = get_pixel(byte, str, parser); 
bmp_parser.c:	if (!(env->textures[index].surface = SDL_CreateRGBSurfaceWithFormat(
bmp_parser.c:	env->textures[index].str = env->textures[index].surface->pixels;
bmp_parser.c:	env->textures[index].scale = 1;
bmp_parser.c:	env->textures[index].xpadding = 0;
bmp_parser.c:	env->textures[index].ypadding = 0;
camera.c:	env->camera.vfov = (180.0 / M_PI) * atan(tan((CONVERT_RADIANS * env->camera.hfov / 2)) / env->camera.ratio) * 2;
camera.c:	//env->camera.hfov = (180.0 / M_PI) * atan(tan(((M_PI / 180.0) * env->cameravfov / 2)) * env->camera.ratio) * 2;
camera.c:	//ft_printf("hfov = %f, vfov = %f\n", env->camera.hfov, env->camera.vfov);
camera.c:	env->camera.near_left = -tan(CONVERT_RADIANS * env->camera.hfov / 2) * env->camera.near_z;
camera.c:	env->camera.near_right = tan(CONVERT_RADIANS * env->camera.hfov / 2) * env->camera.near_z;
camera.c:	env->camera.near_up = -tan(CONVERT_RADIANS * env->camera.vfov / 2) * env->camera.near_z;
camera.c:	env->camera.near_down = tan(CONVERT_RADIANS * env->camera.vfov / 2) * env->camera.near_z;
camera.c:	env->camera.far_left = -tan(CONVERT_RADIANS * env->camera.hfov / 2) * env->camera.far_z;
camera.c:	env->camera.far_right = tan(CONVERT_RADIANS * env->camera.hfov / 2) * env->camera.far_z;
camera.c:	//ft_printf("near left = %f near right = %f\n", env->camera.near_left, env->camera.near_right);
camera.c:	env->camera.x1 = (env->camera.near_left / env->camera.near_z);
camera.c:	env->camera.x2 = (env->camera.near_right / env->camera.near_z);
camera.c:	env->camera.y1 = (env->camera.near_up / env->camera.near_z);
camera.c:	env->camera.y2 = (env->camera.near_down / env->camera.near_z);
camera.c:	//ft_printf("x1 = %f x2 = %f\n", env->camera.x1, env->camera.x2);
camera.c:	env->camera.hscale = env->h_w / env->camera.x2;
camera.c:	env->camera.vscale = env->h_h / env->camera.y2;
camera.c:	env->camera.scale = env->camera.vscale;
camera.c:			env->camera.near_z,
camera.c:			env->camera.near_left,
camera.c:			env->camera.near_right,
camera.c:			env->camera.far_left,
camera.c:			env->camera.far_right);
camera.c:	ft_printf("camera x1 = %f camera x2 = %f\n", env->camera.x1, env->camera.x2);
camera.c:	ft_printf("near_up = %f near_down = %f\n", env->camera.near_up, env->camera.near_down);
camera.c:	ft_printf("camera y1 = %f camera y2 = %f\n", env->camera.y1, env->camera.y2);
camera.c:	ft_printf("hscale = %f\n", env->camera.hscale);
camera.c:	ft_printf("vscale = %f\n", env->camera.vscale);
camera.c:	ft_printf("final scale = %f\n", env->camera.scale);*/
camera.c:	env->camera.hfov = 90;
camera.c:	env->camera.near_z = 0.1;
camera.c:	env->camera.far_z = 1000;
camera.c:	env->camera.ratio_w = 16;
camera.c:	env->camera.ratio_h = 9;
camera.c:	env->camera.ratio = env->camera.ratio_w / env->camera.ratio_h;
check_parsing.c:	ft_printf("{yellow}Vertex %d\n", env->nb_vertices);
check_parsing.c:	while (i < env->nb_vertices)
check_parsing.c:		ft_printf("vertex	%f %f\n", env->vertices[i].y, env->vertices[i].x);
check_parsing.c:	ft_printf("\nSector %d\n", env->nb_sectors);
check_parsing.c:	while (i < env->nb_sectors)
check_parsing.c:		ft_printf("sector	%f %f	", env->sectors[i].floor,
check_parsing.c:				env->sectors[i].ceiling);
check_parsing.c:		while (j < env->sectors[i].nb_vertices)
check_parsing.c:			ft_printf("%d ", env->sectors[i].vertices[j]);
check_parsing.c:		while (j < env->sectors[i].nb_vertices)
check_parsing.c:			ft_printf("%d ", env->sectors[i].neighbors[j]);
check_parsing.c:	ft_printf("\nplayer	%f %f	%f %d\n{reset}", env->player.pos.y,
check_parsing.c:			env->player.pos.x, env->player.angle, env->player.sector);
clear_image.c:	pixels = env->sdl.texture_pixels;
clear_image.c:	zbuffer = env->depth_array;
clear_image.c:	xmax = env->w;
clear_image.c:	ymax = env->h;
clear_image.c:			//env->sdl.img_str[x + y * env->w] = 0xFF;
clipping.c:	max = env->nb_vertices;
clipping.c:		env->vertices[i].clipped[0] = 0;
clipping.c:		env->vertices[i].clipped[1] = 0;
clipping.c:		env->vertices[i].clipped_x[0] = env->vertices[i].x;
clipping.c:		env->vertices[i].clipped_x[1] = env->vertices[i].x;
clipping.c:		env->vertices[i].clipped_y[0] = env->vertices[i].y;
clipping.c:		env->vertices[i].clipped_y[1] = env->vertices[i].y;
clipping.c:	while (i < env->nb_sectors)
clipping.c:		max = env->sectors[i].nb_vertices;
clipping.c:			env->sectors[i].clipped_floors1[j] = env->sectors[i].floors[j];
clipping.c:			env->sectors[i].clipped_ceilings1[j] = env->sectors[i].ceilings[j];
clipping.c:			env->sectors[i].clipped_floors2[j] = env->sectors[i].floors[j];
clipping.c:			env->sectors[i].clipped_ceilings2[j] = env->sectors[i].ceilings[j];
clipping.c:			new_v2(env->camera.near_left, env->camera.near_z),
clipping.c:			new_v2(env->camera.far_left, env->camera.far_z));
clipping.c:			new_v2(env->camera.near_right, env->camera.near_z),
clipping.c:			new_v2(env->camera.far_right, env->camera.far_z));
clipping.c:				new_v2(env->camera.near_left, env->camera.near_z),
clipping.c:				new_v2(env->camera.near_right, env->camera.near_z));
clipping.c:				new_v2(env->camera.far_left, env->camera.far_z),
clipping.c:				new_v2(env->camera.far_right, env->camera.far_z));
clipping.c:	if ((render->vz1 < env->camera.near_z && render->vz2 < env->camera.near_z)
clipping.c:			|| (render->vz1 > env->camera.far_z && render->vz2 > env->camera.far_z)
clipping.c:			|| (render->vx1 < env->camera.far_left && render->vx2 < env->camera.far_left)
clipping.c:			|| (render->vx2 > env->camera.far_right && render->vx2 > env->camera.far_right))
clipping.c:	if ((render->inter_left.x >= env->camera.far_left
clipping.c:			&& render->inter_left.x <= env->camera.near_left
clipping.c:			&& render->inter_left.y >= env->camera.near_z
clipping.c:			&& render->inter_left.y <= env->camera.far_z)
clipping.c:			|| (render->inter_right.x >= env->camera.near_right
clipping.c:			&& render->inter_right.x <= env->camera.far_right
clipping.c:			&& render->inter_right.y >= env->camera.near_z
clipping.c:			&& render->inter_right.y <= env->camera.far_z)
clipping.c:			|| (render->inter_far.x >= env->camera.far_left
clipping.c:			&& render->inter_far.x <= env->camera.far_right)
clipping.c:			|| (render->inter_near.x >= env->camera.near_left
clipping.c:			&& render->inter_near.x <= env->camera.near_right))
clipping.c:	/*if (render->vz1 >= env->camera.near_z || render->vz2 >= env->camera.near_z)
clipping.c:	if (render->vz1 < env->camera.near_z)
clipping.c:	if (render->vz2 < env->camera.near_z)
clipping.c:	/*if (render->vz1 <= env->camera.near_z || render->vz2 <= env->camera.near_z)
clipping.c:		if (render->vz1 < env->camera.near_z)
clipping.c:			if(render->inter_left.y > env->camera.near_z)
clipping.c:		if (render->vz2 < env->camera.near_z)
clipping.c:			if(render->inter_left.y > env->camera.near_z)
create_portals.c:				env->sectors[sector.num].neighbors[i - 1] = data.father;
create_portals.c:				env->sectors[data.father].neighbors[data.index] = sector.num;
create_portals.c:				env->sectors[sector.num].
create_portals.c:				env->sectors[data.father].neighbors[data.index] = sector.num;
create_portals.c:				env->sectors[sector.num].neighbors[i] = data.father;
create_portals.c:				env->sectors[data.father].neighbors[data.index] = sector.num;
create_portals.c:	while (i < env->nb_sectors)
create_portals.c:		find_common_wall(env, env->sectors[i], data);
delete_object.c:	env->objects = ft_delindex(env->objects,
delete_object.c:			sizeof(t_object) * env->nb_objects,
delete_object.c:	env->nb_objects--;
delete_object.c:	env->editor.selected_object = -1;
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		while (j < env->sectors[i].nb_vertices)
delete_sector.c:			if (env->sectors[i].neighbors[j] >= sector)
delete_sector.c:				env->sectors[i].neighbors[j]--;
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].vertices);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].neighbors);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].textures);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].floors);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].ceilings);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_ceilings1);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_ceilings2);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_floors1);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_floors2);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].wall_width);
delete_sector.c:	env->sectors = ft_delindex(env->sectors,
delete_sector.c:			 sizeof(t_sector) * env->nb_sectors,
delete_sector.c:	env->nb_sectors--;
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		env->sectors[i].num--;
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		if (env->sectors[i].nb_vertices < 3)
delete_vertex.c:	while (i < env->nb_sectors)
delete_vertex.c:			if (env->sectors[i].num == sectors[j])
delete_vertex.c:			while (k < env->sectors[i].nb_vertices)
delete_vertex.c:				if (env->sectors[i].vertices[k] > vertex)
delete_vertex.c:					env->sectors[i].vertices[k]--;;
delete_vertex.c:		while (index < env->sectors[sectors[i]].nb_vertices)
delete_vertex.c:			if (env->sectors[sectors[i]].vertices[index] == vertex)
delete_vertex.c:		if (env->sectors[sectors[i]].nb_vertices - 1 < 3)
delete_vertex.c:			tmp = env->sectors[sectors[i]];
delete_vertex.c:			env->sectors[sectors[i]].vertices = ft_delindex(env->sectors[sectors[i]].vertices,
delete_vertex.c:					(env->sectors[sectors[i]].nb_vertices + 1) * sizeof(short),
delete_vertex.c:			env->sectors[sectors[i]].nb_vertices--;
delete_vertex.c:			while (j < env->sectors[sectors[i]].nb_vertices)
delete_vertex.c:				if (env->sectors[sectors[i]].vertices[j] > index)
delete_vertex.c:					env->sectors[sectors[i]].vertices[j]--;
delete_vertex.c:			env->sectors[sectors[i]].vertices[env->sectors[sectors[i]].nb_vertices] = env->sectors[sectors[i]].vertices[0];
delete_vertex.c:	while (i < env->nb_sectors)
delete_vertex.c:		while (j < env->sectors[i].nb_vertices)
delete_vertex.c:			if (env->sectors[i].vertices[j] == vertex)
delete_vertex.c:					env->sectors[i].vertices = ft_delindex(env->sectors[i].vertices,
delete_vertex.c:							sizeof(short) * (env->sectors[i].nb_vertices + 1),
delete_vertex.c:					env->sectors[i].nb_vertices--;
delete_vertex.c:			if (env->sectors[i].vertices[j] > vertex)
delete_vertex.c:				env->sectors[i].vertices[j]--;
delete_vertex.c:		env->sectors[i].vertices[env->sectors[i].nb_vertices] = env->sectors[i].vertices[0];
delete_vertex.c:	//ft_printf("%d\n%d\n%d\n\n", sizeof(t_vertex) * env->nb_vertices, sizeof(t_vertex), sizeof(t_vertex) * vertex);
delete_vertex.c:	env->vertices = ft_delindex(env->vertices,
delete_vertex.c:			sizeof(t_vertex) * env->nb_vertices,
delete_vertex.c:	env->nb_vertices--;
delete_vertex.c:	while (i < env->nb_vertices)
delete_vertex.c:		env->vertices[i].num--;
delete_vertex.c:	if (env->nb_sectors)
delete_vertex.c:	env->editor.selected_vertex = -1;
delete_vertex.c:	while (i < env->nb_vertices)
doom.c:	while (env->running)
doom.c:		Mix_VolumeMusic(MIX_MAX_VOLUME/env->sound.g_music);
doom.c:		SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
doom.c:		SDL_GetMouseState(&env->sdl.mx, &env->sdl.my);
doom.c:		while (SDL_PollEvent(&env->sdl.event))
doom.c:			if (env->sdl.event.type == SDL_QUIT || (env->sdl.event.type == SDL_KEYUP && env->sdl.event.key.keysym.sym == SDLK_ESCAPE))
doom.c:				env->running = 0;
doom.c:			else if (env->sdl.event.type == SDL_KEYDOWN
doom.c:					|| env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONDOWN
doom.c:					|| env->sdl.event.type == SDL_MOUSEBUTTONUP || env->sdl.event.type == SDL_MOUSEWHEEL)
doom.c:			if (env->sdl.event.type == SDL_KEYUP)
doom.c:			if (env->sdl.event.type == SDL_MOUSEWHEEL && !env->weapon_change.on_going && !env->shot.on_going)
doom.c:		if (env->menu_start)
doom.c:			if (env->option)
draw_circle.c:		if (p1.x >= 0 && p1.x < env->w && p1.y >= 0 && p1.y < env->h)
draw_circle.c:		env->sdl.texture_pixels[p1.x + p1.y * env->w] = color;
draw_circle.c:		if (p1.x >= 0 && p1.x < env->w && p1.y >= 0 && p1.y < env->h)
draw_circle.c:			env->sdl.texture_pixels[p1.x + p1.y * env->w] = color;
draw_circle.c:		if (circle.center.x + x >= 0 && circle.center.x + x < env->w
draw_circle.c:				&& circle.center.y + y >= 0 && circle.center.y + y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + x + env->w * (circle.center.y + y)] = circle.line_color;
draw_circle.c:		if (circle.center.x - x >= 0 && circle.center.x - x < env->w
draw_circle.c:				&& circle.center.y + y >= 0 && circle.center.y + y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - x + env->w * (circle.center.y + y)] = circle.line_color;
draw_circle.c:		if (circle.center.x + x >= 0 && circle.center.x + x < env->w
draw_circle.c:				&& circle.center.y - y >= 0 && circle.center.y - y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + x + env->w * (circle.center.y - y)] = circle.line_color;
draw_circle.c:		if (circle.center.x - x >= 0 && circle.center.x - x < env->w
draw_circle.c:				&& circle.center.y - y >= 0 && circle.center.y - y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - x + env->w * (circle.center.y - y)] = circle.line_color;
draw_circle.c:		if (circle.center.x + y >= 0 && circle.center.x + y < env->w
draw_circle.c:				&& circle.center.y + x >= 0 && circle.center.y + x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + y + env->w * (circle.center.y + x)] = circle.line_color;
draw_circle.c:		if (circle.center.x - y >= 0 && circle.center.x - y < env->w
draw_circle.c:				&& circle.center.y + x >= 0 && circle.center.y + x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - y + env->w * (circle.center.y + x)] = circle.line_color;
draw_circle.c:		if (circle.center.x + y >= 0 && circle.center.x + y < env->w
draw_circle.c:				&& circle.center.y - x >= 0 && circle.center.y - x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + y + env->w * (circle.center.y - x)] = circle.line_color;
draw_circle.c:		if (circle.center.x - y >= 0 && circle.center.x - y < env->w
draw_circle.c:				&& circle.center.y - x >= 0 && circle.center.y - x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - y + env->w * (circle.center.y - x)] = circle.line_color;
draw_functions.c:	texture = env->textures[render.texture];
draw_functions.c:	pixels = env->sdl.texture_pixels;
draw_functions.c:	zbuffer = env->depth_array;
draw_functions.c:		coord = vline.x + env->w * i;
draw_functions.c:		if (!env->options.lighting)
draw_functions.c:	if (env->options.zbuffer || env->options.contouring)
draw_functions.c:			start_coord = vline.x + env->w * vline.start;
draw_functions.c:			end_coord = vline.x + env->w * vline.end;
draw_functions.c:	pixels = env->sdl.texture_pixels;
draw_functions.c:	zbuffer = env->depth_array;
draw_functions.c:		coord = vline.x + env->w * vline.start;
draw_functions.c:	pixels = env->sdl.texture_pixels;
draw_functions.c:	zbuffer = env->depth_array;
draw_functions.c:	texture_w = env->textures[render.ceiling_texture].surface->w;
draw_functions.c:	texture_h = env->textures[render.ceiling_texture].surface->h;
draw_functions.c:	texture_pixels = env->textures[render.ceiling_texture].str;
draw_functions.c:		coord = vline.x + env->w * i;
draw_functions.c:		y = alpha * render.texel.y + (1.0 - alpha) * env->player.pos.y;
draw_functions.c:		x = alpha * render.texel.x + (1.0 - alpha) * env->player.pos.x;
draw_functions.c:			if (!env->options.lighting)
draw_functions.c:	if (env->options.zbuffer || env->options.contouring)
draw_functions.c:		if (vline.start >= 0 && vline.start < env->h - 1)
draw_functions.c:			pixels[vline.x + env->w * vline.start] = 0xFFFF0000;
draw_functions.c:			zbuffer[vline.x + env->w * vline.start] = 100000000;
draw_functions.c:				&& vline.end >= 0 && vline.end < env->h)
draw_functions.c:			pixels[vline.x + env->w * vline.end] = 0xFFFF0000;
draw_functions.c:			zbuffer[vline.x + env->w * vline.end] = 100000000;
draw_functions.c:	pixels = env->sdl.texture_pixels;
draw_functions.c:	zbuffer = env->depth_array;
draw_functions.c:	texture_w = env->textures[render.floor_texture].surface->w;
draw_functions.c:	texture_h = env->textures[render.floor_texture].surface->h;
draw_functions.c:	texture_pixels = env->textures[render.floor_texture].str;
draw_functions.c:		coord = vline.x + env->w * i;
draw_functions.c:		//y = alpha * render.texel.y + (1.0 - alpha) * env->player.pos.y;
draw_functions.c:		y = alpha * render.texel.y + (1.0 - alpha) * env->player.camera_y;
draw_functions.c:		/*y = ((1.0 - alpha) * env->player.camera_y / env->camera.near_z + alpha * render.texel.y / render.z)
draw_functions.c:			/ ((1.0 - alpha) / env->camera.near_z + alpha / render.z);*/
draw_functions.c:		//x = alpha * render.texel.x + (1.0 - alpha) * env->player.pos.x;
draw_functions.c:		x = alpha * render.texel.x + (1.0 - alpha) * env->player.camera_x;
draw_functions.c:		/*x = ((1.0 - alpha) * env->player.camera_x / env->camera.near_z + alpha * render.texel.y / render.z)
draw_functions.c:			/ ((1.0 - alpha) / env->camera.near_z + alpha / render.z);*/
draw_functions.c:			if (!env->options.lighting)
draw_functions.c:	if (env->options.zbuffer || env->options.contouring)
draw_functions.c:				&& vline.start >= 0 && vline.start < env->h)
draw_functions.c:			pixels[vline.x + env->w * vline.start] = 0xFFFF0000;
draw_functions.c:			zbuffer[vline.x + env->w * vline.start] = 100000000;
draw_functions.c:		if (vline.end < env->h - 1 && vline.end >= 0)
draw_functions.c:			pixels[vline.x + env->w * vline.end] = 0xFFFF0000;
draw_functions.c:			zbuffer[vline.x + env->w * vline.end] = 100000000;
draw_functions.c:	vline.start = env->ymin[vline.x];
draw_functions.c:	vline.end = ft_min(render.current_ceiling - 1, env->h - 1);
draw_functions.c:	if (env->options.lighting)
draw_functions.c:	/*if (env->sectors[render.sector].ceiling_slope)
draw_functions.c:	vline.end = env->ymax[vline.x];
draw_functions.c:	if (env->options.lighting)
draw_functions.c:	/*if (env->sectors[render.sector].floor_slope)
draw_functions.c:	if (env->options.lighting)
draw_functions.c:	if ((env->options.zbuffer || env->options.contouring) && (render.currentx == render.preclip_x1 || render.currentx == render.preclip_x2))
draw_functions.c:	if ((env->options.zbuffer || env->options.contouring) && vline.end == (int)render.max_neighbor_ceiling)
draw_functions.c:		env->sdl.texture_pixels[env->w * (vline.end - 1) + vline.x] = 0xFFFF0000;
draw_functions.c:		env->depth_array[env->w * (vline.end - 1) + vline.x] = 100000000;
draw_functions.c:	if (env->options.lighting)
draw_functions.c:	if ((env->options.zbuffer || env->options.contouring) && (render.currentx == render.preclip_x1 || render.currentx == render.preclip_x2))
draw_functions.c:	if ((env->options.zbuffer || env->options.contouring) && vline.start == (int)render.max_neighbor_floor)
draw_functions.c:		env->sdl.texture_pixels[env->w * (vline.start + 1) + vline.x] = 0xFFFF0000;
draw_functions.c:		env->depth_array[env->w * (vline.start + 1) + vline.x] = 100000000;
draw_game.c:	SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
draw_game.c:	if (env->options.wall_color)
draw_game.c:	if ((env->inputs.left_click && !env->shot.on_going && !env->weapon_change.on_going) || env->shot.on_going)
draw_game.c:		weapon_animation(env, env->player.curr_weapon);
draw_game.c:		draw_weapon(env, env->weapons[env->player.curr_weapon].first_sprite);
draw_game.c:	if (env->weapon_change.on_going && !env->shot.on_going)
draw_game.c:	if (env->options.show_fps)
draw_game.c:	if (env->options.test)
draw_game.c:	if (env->options.show_minimap)
draw_game.c:	if (env->options.zbuffer)
draw_grid.c:	pixels = env->sdl.texture_pixels;
draw_grid.c:	x = env->editor.center.x;
draw_grid.c:	if (x >= 200 && x < env->w)
draw_grid.c:		y = ft_clamp(env->editor.center.y - 10, 0, env->h - 1);
draw_grid.c:		max = ft_clamp(env->editor.center.y, 0, env->h - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid.c:		y = ft_clamp(env->editor.center.y + 10, 0, env->h - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid.c:	y = env->editor.center.y;
draw_grid.c:	if (y >= 0 && y < env->h)
draw_grid.c:		x = ft_clamp(env->editor.center.x - 10, 199, env->w);
draw_grid.c:		max = ft_clamp(env->editor.center.x, 199, env->w - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid.c:		x = ft_clamp(env->editor.center.x + 10, 199, env->w - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid_objects.c:	if (env->editor.selected_object != -1)
draw_grid_objects.c:		scale = env->editor.scale / 2.0;
draw_grid_objects.c:		center.x = env->sdl.mx;
draw_grid_objects.c:		center.y = env->sdl.my;
draw_grid_objects.c:	while (i < env->nb_objects)
draw_grid_objects.c:		center.x = env->objects[i].pos.x * env->editor.scale + env->editor.center.x;
draw_grid_objects.c:		center.y = env->objects[i].pos.y * env->editor.scale + env->editor.center.y;
draw_grid_objects.c:		if (env->sdl.mx > center.x - env->editor.scale / 2.0
draw_grid_objects.c:				&& env->sdl.mx < center.x + env->editor.scale / 2.0
draw_grid_objects.c:				&& env->sdl.my > center.y - env->editor.scale / 2.0
draw_grid_objects.c:				&& env->sdl.my < center.y + env->editor.scale / 2.0)
draw_grid_objects.c:			scale = env->editor.scale;
draw_grid_objects.c:			if (env->inputs.left_click
draw_grid_objects.c:					&& env->editor.start_vertex == -1
draw_grid_objects.c:					&& env->editor.selected_player == -1
draw_grid_objects.c:					&& env->editor.selected_object == -1
draw_grid_objects.c:					&& env->editor.selected_vertex == -1)
draw_grid_objects.c:				env->editor.selected_object = i;
draw_grid_objects.c:			scale = env->editor.scale / 2.0;
draw_grid_objects.c:		if (env->editor.selected_object != i)
draw_grid_player.c:	if (env->editor.selected_player == 1)
draw_grid_player.c:		circle.center.x = env->sdl.mx;
draw_grid_player.c:		circle.center.y = env->sdl.my;
draw_grid_player.c:		circle.radius = env->editor.scale;
draw_grid_player.c:		circle.center.x = (env->player.pos.x * env->editor.scale) + env->editor.center.x;
draw_grid_player.c:		circle.center.y = (env->player.pos.y * env->editor.scale) + env->editor.center.y;
draw_grid_player.c:		if (env->sdl.mx > circle.center.x - env->editor.scale / 2
draw_grid_player.c:				&& env->sdl.mx < circle.center.x + env->editor.scale / 2
draw_grid_player.c:				&& env->sdl.my > circle.center.y - env->editor.scale / 2
draw_grid_player.c:				&& env->sdl.my < circle.center.y + env->editor.scale / 2)
draw_grid_player.c:			circle.radius = env->editor.scale;
draw_grid_player.c:			if (env->inputs.left_click
draw_grid_player.c:					&& env->editor.start_vertex == -1
draw_grid_player.c:					&& env->editor.selected_player == -1
draw_grid_player.c:					&& env->editor.selected_object == -1
draw_grid_player.c:					&& env->editor.selected_vertex == -1)
draw_grid_player.c:				env->editor.selected_player = 1;
draw_grid_player.c:			circle.radius = env->editor.scale / 2;
draw_grid_vertices.c:	if (env->editor.selected_vertex != -1)
draw_grid_vertices.c:		scale = env->editor.scale / 5.0;
draw_grid_vertices.c:		env->vertices[env->editor.selected_vertex].x = round((env->sdl.mx - env->editor.center.x) / env->editor.scale);
draw_grid_vertices.c:		env->vertices[env->editor.selected_vertex].y = round((env->sdl.my - env->editor.center.y) / env->editor.scale);
draw_grid_vertices.c:		center.x = env->vertices[env->editor.selected_vertex].x * env->editor.scale + env->editor.center.x;
draw_grid_vertices.c:		center.y = env->vertices[env->editor.selected_vertex].y * env->editor.scale + env->editor.center.y;
draw_grid_vertices.c:	while (i < env->nb_vertices)
draw_grid_vertices.c:		vertex = env->vertices[i];
draw_grid_vertices.c:		center = new_point(env->editor.center.x + vertex.x * env->editor.scale,
draw_grid_vertices.c:				env->editor.center.y + vertex.y * env->editor.scale);
draw_grid_vertices.c:		if (env->sdl.mx > center.x - env->editor.scale / 3.0
draw_grid_vertices.c:				&& env->sdl.mx < center.x + env->editor.scale / 3.0
draw_grid_vertices.c:				&& env->sdl.my > center.y - env->editor.scale / 3.0
draw_grid_vertices.c:				&& env->sdl.my < center.y + env->editor.scale / 3.0)
draw_grid_vertices.c:			scale = env->editor.scale / 3.0;
draw_grid_vertices.c:			if (env->inputs.left_click
draw_grid_vertices.c:					&& env->editor.start_vertex == -1
draw_grid_vertices.c:					&& env->editor.selected_vertex == -1
draw_grid_vertices.c:					&& env->editor.selected_player == -1
draw_grid_vertices.c:					&& env->editor.selected_object == -1)
draw_grid_vertices.c:				env->editor.selected_vertex = i;
draw_grid_vertices.c:				env->editor.start_pos.x = env->vertices[env->editor.selected_vertex].x;
draw_grid_vertices.c:				env->editor.start_pos.y = env->vertices[env->editor.selected_vertex].y;
draw_grid_vertices.c:			if (env->inputs.del && !current_vertices_contains(env, i))
draw_grid_vertices.c:				env->editor.selected_vertex = i;
draw_grid_vertices.c:			scale = env->editor.scale / 5.0;
draw_grid_vertices.c:		if (env->editor.selected_vertex == i)
draw_grid_walls.c:	tmp = env->editor.current_vertices;
draw_grid_walls.c:	v1.x = env->editor.center.x + v->x * env->editor.scale;
draw_grid_walls.c:	v1.y = env->editor.center.y + v->y * env->editor.scale;
draw_grid_walls.c:		v2.x = env->editor.center.x + v->x * env->editor.scale;
draw_grid_walls.c:		v2.y = env->editor.center.y + v->y * env->editor.scale;
draw_grid_walls.c:	if (env->drawing)
draw_grid_walls.c:		v2.x = env->sdl.mx;
draw_grid_walls.c:		v2.y = env->sdl.my;
draw_grid_walls.c:		v1.x = env->editor.center.x +
draw_grid_walls.c:			env->vertices[sector.vertices[i]].x * env->editor.scale;
draw_grid_walls.c:		v1.y = env->editor.center.y +
draw_grid_walls.c:			env->vertices[sector.vertices[i]].y * env->editor.scale;
draw_grid_walls.c:		v2.x = env->editor.center.x +
draw_grid_walls.c:			env->vertices[sector.vertices[i + 1]].x * env->editor.scale;
draw_grid_walls.c:		v2.y = env->editor.center.y +
draw_grid_walls.c:			env->vertices[sector.vertices[i + 1]].y * env->editor.scale;
draw_grid_walls.c:	while (i < env->nb_sectors)
draw_grid_walls.c:		if (i == env->editor.selected_sector)
draw_grid_walls.c:			draw_grid_sector(env->sectors[i], 0xFF00FF00, env);
draw_grid_walls.c:			draw_grid_sector(env->sectors[i], 0xFFFFFFFF, env);
draw_hud.c:	window_w = (int)(env->w)/*  - env->textures[ARMOR_LIFE_HUD].surface->w */;
draw_hud.c:	window_h = (env->h - env->textures[ARMOR_LIFE_HUD].surface->h);
draw_hud.c:	while (x < env->textures[ARMOR_LIFE_HUD].surface->w && window_w + x < env->w)
draw_hud.c:		while (y < env->textures[ARMOR_LIFE_HUD].surface->h  && (window_h + y) < env->h)
draw_hud.c:			if (env->textures[ARMOR_LIFE_HUD].str[x + env->textures[ARMOR_LIFE_HUD].surface->w * y] != 0xFFC10099)
draw_hud.c:				env->sdl.texture_pixels[(window_w + x) + env->w * (window_h + y)] = 
draw_hud.c:					env->textures[ARMOR_LIFE_HUD].str[x + env->textures[ARMOR_LIFE_HUD].surface->w * y];
draw_hud.c:	window_w = (int)(env->w) - env->textures[AMMO_HUD].surface->w;
draw_hud.c:	window_h = (env->h - env->textures[AMMO_HUD].surface->h);
draw_hud.c:	while (x < env->textures[AMMO_HUD].surface->w)
draw_hud.c:		while (y < env->textures[AMMO_HUD].surface->h  && (window_h + y) < env->h)
draw_hud.c:			if (env->textures[AMMO_HUD].str[x + env->textures[AMMO_HUD].surface->w * y] != 0xFFC10099)
draw_hud.c:				env->sdl.texture_pixels[(window_w + x) + env->w * (window_h + y)] = 
draw_hud.c:					env->textures[AMMO_HUD].str[x + env->textures[AMMO_HUD].surface->w * y];
draw_hud.c:	str = ft_sitoa(env->player.life);
draw_hud.c:	print_text(new_point(830, 300), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
draw_hud.c:	str = ft_sitoa(env->player.armor);
draw_hud.c:	print_text(new_point(830, 80), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
draw_sprites.c:	sprite = env->sprites[object.sprite];
draw_sprites.c:	texture = env->textures[sprite.texture];
draw_sprites.c:	pixels = env->sdl.texture_pixels;
draw_sprites.c:	zbuffer = env->depth_array;
draw_sprites.c:			if ((object.rotated_pos.z < zbuffer[x + y * env->w]
draw_sprites.c:				if (!env->options.lighting)
draw_sprites.c:					pixels[x + y * env->w] = texture_pixels[textx + texty * texture.surface->w];
draw_sprites.c:					pixels[x + y * env->w] = apply_light(texture_pixels[textx + texty * texture.surface->w], orender.light);
draw_sprites.c:				zbuffer[x + y * env->w] = object.rotated_pos.z;
draw_sprites.c:	sprite = env->sprites[object->sprite];
draw_sprites.c:	orender.xstart = ft_clamp(orender.x1, 0, env->w - 1);
draw_sprites.c:	orender.ystart = ft_clamp(orender.y1 + 1, 0, env->h - 1);
draw_sprites.c:	orender.xend = ft_clamp(orender.x2, 0, env->w - 1);
draw_sprites.c:	orender.yend = ft_clamp(orender.y2, 0, env->h - 1);
draw_sprites.c:	if (((orender.x1 + orender.x2) / 2) < env->w && ((orender.x1 + orender.x2) / 2) >= 0 && ((orender.y1 + orender.y2) / 2) < env->h && ((orender.y1 + orender.y2) / 2) >= 0)
draw_sprites.c:		if (env->depth_array[(orender.x1 + orender.x2) / 2 + env->w * ((orender.y1 + orender.y2) / 2)] == object->rotated_pos.z)
draw_sprites.c:	while (i < env->nb_objects)
draw_sprites.c:		get_translated_object_pos(env, &env->objects[i]);
draw_sprites.c:		get_rotated_object_pos(env, &env->objects[i]);
draw_sprites.c:	env->current_object = 0;
draw_sprites.c:		object_threads[i].xstart = env->nb_objects / (double)THREADS * i;
draw_sprites.c:		object_threads[i].xend = env->nb_objects / (double)THREADS * (i + 1);
draw_sprites.c:	//sort_objects(env->objects, 0, env->nb_objects - 1);
draw_sprites.c:	while (i < env->nb_objects)
draw_sprites.c:		if (env->objects[i].rotated_pos.z > 1 && env->objects[i].exists)
draw_sprites.c:			draw_object(&env->objects[i], env);
editor.c:	while (env->running)
editor.c:		SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
editor.c:		SDL_GetMouseState(&env->sdl.mx, &env->sdl.my);
editor.c:		while (SDL_PollEvent(&env->sdl.event))
editor.c:			if (env->sdl.event.type == SDL_QUIT || (env->sdl.event.type == SDL_KEYUP && env->sdl.event.key.keysym.sym == SDLK_ESCAPE))
editor.c:				env->running = 0;
editor.c:			else if (env->sdl.event.type == SDL_KEYDOWN
editor.c:					|| env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONDOWN
editor.c:					|| env->sdl.event.type == SDL_MOUSEBUTTONUP || env->sdl.event.type == SDL_MOUSEWHEEL)
editor.c:			if (env->sdl.event.type == SDL_KEYUP)
editor.c:			if (!env->editor.in_game && env->sdl.event.type == SDL_MOUSEWHEEL)
editor.c:				if (env->sdl.event.wheel.y > 0 && env->editor.scale * 1.1 < 500)
editor.c:					env->editor.scale *= 1.1;
editor.c:				if (env->sdl.event.wheel.y < 0 && env->editor.scale / 1.1 > 10)
editor.c:					env->editor.scale /= 1.1;
editor.c:		if (!env->editor.in_game)
editor.c:			if (env->editor.new_player || env->editor.selected_player == 1)
editor.c:			if (env->editor.selected_object != -1 || env->nb_objects > 0)
editor.c:			if (env->editor.start_vertex != -1)
editor.c:		if (env->editor.in_game && env->inputs.shift)
editor_hud.c:	draw_circle(new_circle(0xFFFF0000, 0xFFFF0000, center, (env->editor.scale / 2)), env);
editor_hud.c:	print_text(new_point(150, 60), new_printable_text("Player", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	draw_circle(new_circle(0xFFFFFF00, 0xFFFFFF00, center, (env->editor.scale / 2)), env);
editor_hud.c:	print_text(new_point(250, 60), new_printable_text("Object", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 220), new_printable_text("Selected sector: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	if (env->editor.selected_sector == -1)
editor_hud.c:		print_text(new_point(10, 430), new_printable_text("none", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(10, 430), new_printable_text(ft_sitoa(env->editor.selected_sector), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_keys.c:	if (env->inputs.space
editor_keys.c:			&& env->editor.selected_player == -1
editor_keys.c:			&& env->editor.selected_object == -1
editor_keys.c:			&& env->editor.selected_vertex == -1)
editor_keys.c:			add_vertex_to_current_sector(env, env->nb_vertices - 1);
editor_keys.c:			if (env->editor.start_vertex == -1) //Nouveau secteur
editor_keys.c:				env->editor.start_vertex = env->nb_vertices - 1;
editor_keys.c:			if (env->editor.start_vertex == -1)
editor_keys.c:				env->editor.start_vertex = clicked_vertex;
editor_keys.c:				if (clicked_vertex == ((t_vertex*)env->editor.current_vertices->content)->num
editor_keys.c:						&& ft_lstlen(env->editor.current_vertices) > 2
editor_keys.c:					env->editor.reverted = get_clockwise_order(env) ? 0 : 1;
editor_keys.c:					env->editor.start_vertex = -1;
editor_keys.c:		env->inputs.space = 0;
editor_keys.c:	if (env->inputs.backspace)
editor_keys.c:		env->inputs.backspace = 0;
editor_keys.c:	if (env->inputs.left_click
editor_keys.c:			&& env->editor.start_vertex == -1
editor_keys.c:			&& env->editor.selected_player == -1
editor_keys.c:			&& env->editor.selected_object == -1
editor_keys.c:			&& env->editor.selected_vertex == -1)
editor_keys.c:		env->editor.selected_sector = get_sector_no_z(env,
editor_keys.c:				new_v3((env->sdl.mx - env->editor.center.x) / env->editor.scale,
editor_keys.c:					(env->sdl.my - env->editor.center.y) / env->editor.scale,
editor_keys.c:	if (env->inputs.right_click)
editor_keys.c:		env->editor.center.x += env->sdl.mouse_x;
editor_keys.c:		env->editor.center.y += env->sdl.mouse_y;
editor_keys.c:	if (env->inputs.enter)
editor_keys.c:			env->editor.in_game = 1;
editor_keys.c:			env->inputs.enter = 0;
editor_keys.c:			if (env->sector_list)
editor_keys.c:				ft_memdel((void**)&env->sector_list);
editor_keys.c:			if (!(env->sector_list = (int*)malloc(sizeof(int) * env->nb_sectors)))
editor_keys.c:			env->sdl.mx = env->w / 2;
editor_keys.c:			env->sdl.my = env->h / 2;
editor_keys.c:		env->inputs.enter = 0;
editor_keys.c:	if (env->inputs.s && env->inputs.ctrl && !valid_map(env))
editor_keys.c:		env->inputs.s = 0;
editor_keys.c:		env->inputs.ctrl = 0;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_c)
editor_options.c:		env->options.contouring = env->options.contouring ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_r)
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_l)
editor_options.c:		env->options.lighting = env->options.lighting ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_m)
editor_options.c:		env->options.show_minimap = env->options.show_minimap ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_f)
editor_options.c:		env->options.show_fps = env->options.show_fps ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_x)
editor_options.c:		env->options.wall_lover = env->options.wall_lover ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_j)
editor_options.c:		env->options.color_clipping = env->options.color_clipping ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_g)
editor_options.c:		env->options.wall_color = env->options.wall_color ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_t)
editor_options.c:		env->options.test = env->options.test ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_i)
editor_options.c:		env->options.clipping = env->options.clipping ? 0 : 1;
editor_options.c:	if (env->sdl.event.key.keysym.sym == SDLK_n)
editor_options.c:		env->drawing = env->drawing ? 0 : 1;
editor_render.c:	if (env->inputs.enter)
editor_render.c:		env->editor.in_game = 0;
editor_render.c:		env->inputs.enter = 0;
editor_render.c:	if (env->options.show_fps)
enemy_utils.c:    if ((env->player.pos.y >= OY1 && env->player.pos.y <= OY2) || (env->player.pos.y >= OY2 && env->player.pos.y <= OY1))
enemy_utils.c:    if ((env->player.pos.x >= OX1 && env->player.pos.x <= OX2) || (env->player.pos.x >= OX2 && env->player.pos.x <= OX1))
enemy_utils.c:    enemy = env->objects[nb];
enemy_utils.c:    while (i < env->sectors[sector].nb_vertices)
enemy_utils.c:        line_2.p2.x = env->player.pos.x;
enemy_utils.c:        line_2.p2.y = env->player.pos.y;
enemy_utils.c:        if (intersect(line_1, line_2) && env->sectors[sector].neighbors[i] < 0)
enemy_utils.c:        else if (intersect(line_1, line_2) && env->sectors[sector].neighbors[i] >= 0 &&
enemy_utils.c:            env->sector_list[env->sectors[sector].neighbors[i]] == 0)
enemy_utils.c:            env->sector_list[env->sectors[sector].neighbors[i]] = 1;
enemy_utils.c:            return (enemy_view(env, nb, env->sectors[sector].neighbors[i]));
enemy_utils.c:        end_pos = (env->player.pos.x - OX1) * (OY2 - OY1) - (env->player.pos.y - OY1) * (OX2 - OX1);
enemy_utils.c:        if (diff_sign(start_pos, end_pos) && check_wall(env, i, enemy, sector) && env->sectors[sector].neighbors[i] < 0)
enemy_utils.c:        else if (diff_sign(start_pos, end_pos) && check_wall(env, i, enemy, sector) && env->sectors[sector].neighbors[i] >= 0 &&
enemy_utils.c:            env->sector_list[env->sectors[sector].neighbors[i]] == 0 && end_pos != 0)
enemy_utils.c:            env->sector_list[env->sectors[sector].neighbors[i]] = 1;
enemy_utils.c:            return (enemy_view(env, nb, env->sectors[sector].neighbors[i]));
enemy_utils.c:    if (sector != env->player.sector)
enemy_utils.c:    while (i < env->nb_objects)
enemy_utils.c:        while (j < env->nb_sectors)
enemy_utils.c:            if (j == env->objects[i].sector)
enemy_utils.c:                env->sector_list[j] = 1;
enemy_utils.c:                env->sector_list[j] = 0;
enemy_utils.c:        if (env->objects[i].sprite == 1 && enemy_view(env, i, env->objects[i].sector))
enemy_utils.c:            tmp_z = env->player.pos.z;
enemy_utils.c:            env->player.pos.z = env->player.eyesight;
enemy_utils.c:            direction = sprite_movement(0.1, env->objects[i].pos, env->player.pos);
enemy_utils.c:            env->player.pos.z = tmp_z;
enemy_utils.c:            env->objects[i].pos.x += direction.x;
enemy_utils.c:            env->objects[i].pos.y += direction.y;
enemy_utils.c:            env->objects[i].pos.z += direction.z;
enemy_utils.c:            env->objects[i].sector = get_sector(env, env->objects[i].pos, env->objects[i].sector);
enemy_utils.c:            //env->objects[i].angle = -env->player.angle * CONVERT_DEGREES;
enemy_utils.c:            /*ft_printf("angle player %f\n", env->player.angle* CONVERT_DEGREES);
enemy_utils.c:            ft_printf("enemy %f\n", env->objects[i].angle);
enemy_utils.c:            env->objects[i].angle = sprite_rotate(env->objects[i].angle, -env->player.angle * CONVERT_DEGREES);*/
fill_new_sector.c:		if (env->editor.reverted)
fill_new_sector.c:	if (!env->editor.reverted)
fill_new_sector.c:	tmp = env->editor.current_vertices;
fill_new_sector.c:		if (env->editor.reverted)
fill_new_sector.c:	if (!env->editor.reverted)
fps.c:	env->fps = ft_sitoa(1000 / (new_time - env->sdl.time));
fps.c:	if (env->options.show_fps)
fps.c:					env->fps,
fps.c:					env->sdl.fonts.amazdoom50,
fps.c:	env->sdl.time = new_time;
free_all.c:		if (env->textures[i].surface)
free_all.c:			SDL_FreeSurface(env->textures[i].surface);
free_all.c:	while (i < env->nb_sectors)
free_all.c:		if (env->sectors[i].vertices)
free_all.c:			ft_memdel((void**)&env->sectors[i].vertices);
free_all.c:		if (env->sectors[i].ceilings)
free_all.c:			ft_memdel((void**)&env->sectors[i].ceilings);
free_all.c:		if (env->sectors[i].floors)
free_all.c:			ft_memdel((void**)&env->sectors[i].floors);
free_all.c:		if (env->sectors[i].clipped_ceilings1)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_ceilings1);
free_all.c:		if (env->sectors[i].clipped_floors1)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_floors1);
free_all.c:		if (env->sectors[i].clipped_ceilings2)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_ceilings2);
free_all.c:		if (env->sectors[i].clipped_floors2)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_floors2);
free_all.c:		if (env->sectors[i].wall_width)
free_all.c:			ft_memdel((void**)&env->sectors[i].wall_width);
free_all.c:		if (env->sectors[i].textures)
free_all.c:			ft_memdel((void**)&env->sectors[i].textures);
free_all.c:		if (env->sectors[i].neighbors)
free_all.c:			ft_memdel((void**)&env->sectors[i].neighbors);
free_all.c:	ft_memdel((void**)&env->sectors);
free_all.c:	if (env->xmin)
free_all.c:		ft_memdel((void**)&env->xmin);
free_all.c:	if (env->xmax)
free_all.c:		ft_memdel((void**)&env->xmax);
free_all.c:	if (env->screen_sectors)
free_all.c:		ft_memdel((void**)&env->screen_sectors);
free_all.c:	if (env->rendered_sectors)
free_all.c:		ft_memdel((void**)&env->rendered_sectors);
free_all.c:	if (env->sdl.window)
free_all.c:		SDL_DestroyWindow(env->sdl.window);
free_all.c:	if (env->sdl.renderer)
free_all.c:		SDL_DestroyRenderer(env->sdl.renderer);
free_all.c:	if (env->sdl.texture)
free_all.c:		SDL_DestroyTexture(env->sdl.texture);
free_all.c:	if (env->sdl.texture_pixels)
free_all.c:		ft_memdel((void**)&env->sdl.texture_pixels);
free_all.c:	if (env->depth_array)
free_all.c:		ft_memdel((void**)&env->depth_array);
free_all.c:	if (env->ymin)
free_all.c:		ft_memdel((void**)&env->ymin);
free_all.c:	if (env->ymax)
free_all.c:		ft_memdel((void**)&env->ymax);
free_all.c:	if (env->screen_pos)
free_all.c:		ft_memdel((void**)&env->screen_pos);
free_all.c:	if (env->sdl.fonts.amazdoom70)
free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom70);
free_all.c:	if (env->sdl.fonts.amazdoom50)
free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom50);
free_all.c:	if (env->sdl.fonts.amazdoom20)
free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom20);
free_all.c:	if (env->sdl.fonts.alice30)
free_all.c:		TTF_CloseFont(env->sdl.fonts.alice30);
free_all.c:	if (env->sdl.fonts.alice70)
free_all.c:		TTF_CloseFont(env->sdl.fonts.alice70);
free_all.c:	if (env->sdl.fonts.bebasneue)
free_all.c:		TTF_CloseFont(env->sdl.fonts.bebasneue);
free_all.c:	if (env->sectors)
free_all.c:	if (env->vertices)
free_all.c:		ft_memdel((void**)&env->vertices);
free_all.c:	if (env->objects)
free_all.c:		ft_memdel((void**)&env->objects);
free_all.c:	if (env->sprites)
free_all.c:		ft_memdel((void**)&env->sprites);
free_all.c:	if (env->sound.background)
free_all.c:		Mix_FreeMusic(env->sound.background);
free_all.c:	if (env->sound.footstep)
free_all.c:		Mix_FreeChunk(env->sound.footstep);
free_all.c:	if (env->sound.jump)
free_all.c:		Mix_FreeChunk(env->sound.jump);
free_all.c:	if (env->sector_list)
free_all.c:		ft_memdel((void**)&env->sector_list);
free_all.c:	if (env->res[0])
free_all.c:		ft_strdel(&env->res[0]);
free_all.c:	if (env->res[1])
free_all.c:		ft_strdel(&env->res[1]);
free_all.c:	if (env->res[2])
free_all.c:		ft_strdel(&env->res[2]);
free_all.c:		if (env->weapons[i].empty)
free_all.c:			Mix_FreeChunk(env->weapons[i].empty);
free_all.c:		if (env->weapons[i].sound)
free_all.c:			Mix_FreeChunk(env->weapons[i].sound);
game_menu.c:	print_text(new_point(780, 850), new_printable_text("START", env->sdl.fonts.amazdoom70, 0xFFFFFFFF, 70), env);
get_clockwise_order.c:	while (i < env->sectors[index].nb_vertices - 1)
get_clockwise_order.c:		num = env->sectors[index].vertices[i];
get_clockwise_order.c:		vertex1 = env->vertices[num];
get_clockwise_order.c:		num = env->sectors[index].vertices[i + 1];
get_clockwise_order.c:		vertex2 = env->vertices[num];
get_clockwise_order.c:	num = env->sectors[index].vertices[0];
get_clockwise_order.c:	vertex2 = env->vertices[num];
get_clockwise_order.c:	tmp = env->editor.current_vertices;
get_clockwise_order.c:	vertex2 = (t_vertex*)env->editor.current_vertices->content;
get_existing_vertex.c:	while (i < env->nb_vertices)
get_existing_vertex.c:		vertex = env->vertices[i];
get_existing_vertex.c:		if (round((env->sdl.mx - env->editor.center.x) / env->editor.scale) == vertex.x
get_existing_vertex.c:				&& round((env->sdl.my - env->editor.center.y) / env->editor.scale) == vertex.y
get_existing_vertex.c:				&& vertex.num != env->vertices[env->editor.selected_vertex].num)
get_existing_vertex.c:	while (i < env->nb_vertices)
get_existing_vertex.c:		vertex = env->vertices[i];
get_existing_vertex.c:		if (round((env->sdl.mx - env->editor.center.x) / env->editor.scale) == vertex.x
get_existing_vertex.c:				&& round((env->sdl.my - env->editor.center.y) / env->editor.scale) == vertex.y)
get_screen_sectors.c:	size = env->screen_sectors_size;
get_screen_sectors.c:	camera_range = env->camera.near_right - env->camera.near_left;
get_screen_sectors.c:	while (x < env->w)
get_screen_sectors.c:		tmp = (x / (double)(env->w - 1)) * camera_range + env->camera.near_left;
get_screen_sectors.c:		curr.y = -env->camera.near_z;
get_screen_sectors.c:		curr.x = tmp * -env->player.angle_sin - curr.y * env->player.angle_cos + env->player.pos.x;
get_screen_sectors.c:		curr.y = tmp * env->player.angle_cos - curr.y * env->player.angle_sin + env->player.pos.y;
get_screen_sectors.c:		curr.z = env->player.head_z;
get_screen_sectors.c:		env->screen_pos[x] = new_v2(curr.x, curr.y);
get_screen_sectors.c:		sect = get_sector(env, curr, env->player.sector);
get_screen_sectors.c:		while (i < env->screen_sectors_size && env->screen_sectors[i] != -1 && env->screen_sectors[i] != sect)
get_screen_sectors.c:		if (i < env->screen_sectors_size && env->screen_sectors[i] == -1 && sect != -1)
get_screen_sectors.c:			env->screen_sectors[i] = sect;
get_screen_sectors.c:			env->xmin[i] = x;
get_screen_sectors.c:		else if (i < env->screen_sectors_size && env->screen_sectors[i] == sect)
get_screen_sectors.c:			env->xmax[i] = x;
get_sector.c:	if (origin < 0 || origin >= env->nb_sectors)
get_sector.c:	while (i < env->sectors[origin].nb_vertices)
get_sector.c:		if (env->sectors[origin].neighbors[i] >= 0)
get_sector.c:			if (is_in_sector(env, env->sectors[origin].neighbors[i], pos))
get_sector.c:				return (env->sectors[origin].neighbors[i]);
get_sector.c:	while (i < env->nb_sectors)
get_sector.c:	while (i < env->nb_sectors)
get_sector.c:	while (i < env->nb_sectors)
get_slope.c:	v1 = env->vertices[sector.vertices[0]];
get_slope.c:	v2 = env->vertices[sector.vertices[1]];
get_slope.c:	v0 = env->vertices[sector.vertices[0]];
get_slope.c:	v1 = env->vertices[sector.vertices[1]];
get_slope.c:	vi = env->vertices[sector.vertices[vertex_nb]];
get_slope.c:	v0 = env->vertices[sector.vertices[0]];
get_slope.c:	v0 = env->vertices[sector.vertices[0]];
get_slope.c:	while (i < env->nb_sectors)
get_slope.c:		ft_printf("sector %d normal = [%f,%f]\n", i, env->sectors[i].normal.x, env->sectors[i].normal.y);
get_slope.c:		ft_printf("floor = %f\nceiling = %f\n", env->sectors[i].floor, env->sectors[i].ceiling);
get_slope.c:		ft_printf("floor_slope = %f\nceiling_slope = %f\n", env->sectors[i].floor_slope, env->sectors[i].ceiling_slope);
get_slope.c:		while (j < env->sectors[i].nb_vertices)
get_slope.c:			printf("vertex %d floor = %f ceiling = %f\n", j, env->sectors[i].floors[j], env->sectors[i].ceilings[j]);
get_slope.c:	if (sector->num < 0 || sector->num > env->nb_sectors)
get_slope.c:		v1 = env->vertices[sector->vertices[i]];
get_slope.c:		v2 = env->vertices[sector->vertices[i + 1]];
get_slope.c:				pow(env->vertices[sector->vertices[i + 1]].x
get_slope.c:					- env->vertices[sector->vertices[i]].x, 2)
get_slope.c:				+ pow(env->vertices[sector->vertices[i + 1]].y
get_slope.c:					- env->vertices[sector->vertices[i]].y, 2));
get_slope.c:	while (i < env->nb_sectors)
get_slope.c:		env->sectors[i].normal = get_sector_normal(env->sectors[i], env);
get_slope.c:		update_sector_slope(env, &env->sectors[i]);
grid_tools.c:	while (x < env->w)
grid_tools.c:		env->sdl.texture_pixels[x + y * env->w] = 0xFF888888;
grid_tools.c:	while (y < env->h)
grid_tools.c:		env->sdl.texture_pixels[x + y * env->w] = 0xFF888888;
grid_tools.c:	i = env->editor.center.y;
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	while (i < env->h)
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	i = env->editor.center.y - env->editor.scale;
grid_tools.c:	while (i >= env->h)
grid_tools.c:		i -= env->editor.scale;
grid_tools.c:		i -= env->editor.scale;
grid_tools.c:	i = env->editor.center.x;
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	while (i < env->w)
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	i = env->editor.center.x - env->editor.scale;
grid_tools.c:	while (i >= env->w)
grid_tools.c:		i -= env->editor.scale;
grid_tools.c:		i -= env->editor.scale;
init_animations.c:	env->time.start = 0;
init_animations.c:	env->time.end = 0;
init_animations.c:	env->player.state = 0;
init_animations.c:	env->gravity.on_going = 1;
init_animations.c:	env->gravity.start = 0;
init_animations.c:	env->gravity.end = 0;
init_animations.c:	env->gravity.weight = 0;
init_animations.c:	env->jump.on_going = 0;
init_animations.c:	env->jump.start = 0;
init_animations.c:	env->jump.nb_frame = 15;
init_animations.c:	env->jump.end = 300;
init_animations.c:	env->crouch.on_going = 0;
init_animations.c:	env->crouch.start = 0;
init_animations.c:	env->crouch.end = 150;
init_animations.c:	env->crouch.nb_frame = 6;
init_animations.c:	env->crouch.tick = env->crouch.end / env->crouch.nb_frame;
init_animations.c:	env->shot.on_going = 0;
init_animations.c:	env->shot.start = 0;
init_animations.c:	env->weapon_change.on_going = 0;
init_animations.c:	env->weapon_change.start = 0;
init_editor.c:	env->editor.in_game = 0;
init_editor.c:	env->editor.center.x = env->h_w;
init_editor.c:	env->editor.center.y = env->h_h;
init_editor.c:	env->editor.scale = 20;
init_editor.c:	env->editor.current_vertices = NULL;
init_editor.c:	env->editor.start_vertex = -1;
init_editor.c:	env->editor.reverted = 0;
init_editor.c:	env->editor.new_player = 0;
init_editor.c:	env->nb_vertices = 0;
init_editor.c:	env->nb_sectors = 0;
init_editor.c:	env->nb_objects = 0;
init_editor.c:	env->player.sector = -1;
init_editor.c:	env->editor.start_pos.x = 0;
init_editor.c:	env->editor.start_pos.y = 0;
init_editor.c:	env->editor.selected_sector = -1;
init_editor.c:	env->editor.selected_object = -1;
init_editor.c:	env->editor.selected_vertex = -1;
init_editor.c:	env->editor.selected_player = -1;
init_keys.c:	env->keys.forward = SDLK_w;
init_keys.c:	env->keys.s = SDLK_s;
init_keys.c:	env->keys.left = SDLK_a;
init_keys.c:	env->keys.right = SDLK_d;
init_keys.c:	env->keys.forward2 = SDLK_UP;
init_keys.c:	env->keys.backward2 = SDLK_DOWN;
init_keys.c:	env->keys.left2 = SDLK_LEFT;
init_keys.c:	env->keys.right2 = SDLK_RIGHT;
init_keys.c:	env->keys.plus = SDLK_KP_PLUS;
init_keys.c:	env->keys.minus = SDLK_KP_MINUS;
init_keys.c:	env->keys.shift = SDLK_LSHIFT;
init_keys.c:	env->keys.ctrl = SDLK_LCTRL;
init_keys.c:	env->keys.space = SDLK_SPACE;
init_keys.c:	env->keys.up = SDLK_PAGEUP;
init_keys.c:	env->keys.down = SDLK_PAGEDOWN;
init_keys.c:	env->keys.option = SDLK_o;
init_keys.c:	env->keys.enter = SDLK_RETURN;
init_keys.c:	env->keys.backspace = SDLK_BACKSPACE;
init_keys.c:	env->keys.del = SDLK_DELETE;
init_options.c:	env->options.contouring = 0;
init_options.c:	env->options.render_sectors = 1;
init_options.c:	env->options.lighting = 0;
init_options.c:	env->options.show_minimap = 1;
init_options.c:	env->options.wall_lover = 0;
init_options.c:	env->options.show_fps = 1;
init_options.c:	env->options.color_clipping = 0;
init_options.c:	env->options.wall_color = 1;
init_options.c:	env->options.test = 0;
init_options.c:	env->options.minimap_scale = 10;
init_options.c:	env->options.clipping = 1;
init_options.c:	env->option = 0;
init_options.c:	env->options.show_ennemies = 1;
init_options.c:	env->options.zbuffer = 0;
init_pointers.c:	env->sectors = NULL;
init_pointers.c:	env->vertices = NULL;
init_pointers.c:	env->objects = NULL;
init_pointers.c:	env->sprites = NULL;
init_pointers.c:	env->sdl.window = NULL;
init_pointers.c:	env->sdl.renderer = NULL;
init_pointers.c:	env->sdl.texture = NULL;
init_pointers.c:	env->sdl.texture_pixels = NULL;
init_pointers.c:	env->xmin = NULL;
init_pointers.c:	env->xmax = NULL;
init_pointers.c:	env->screen_sectors = NULL;
init_pointers.c:	env->depth_array = NULL;
init_pointers.c:	env->rendered_sectors = NULL;
init_pointers.c:	env->sdl.fonts.amazdoom20 = NULL;
init_pointers.c:	env->sdl.fonts.amazdoom50 = NULL;
init_pointers.c:	env->sdl.fonts.bebasneue = NULL;
init_pointers.c:	env->sdl.fonts.alice30 = NULL;
init_pointers.c:	env->sdl.fonts.alice70 = NULL;
init_pointers.c:	env->screen_pos = NULL;
init_pointers.c:	env->sound.background = NULL;
init_pointers.c:	env->sound.footstep = NULL;
init_pointers.c:	env->sound.jump = NULL;
init_pointers.c:	env->sector_list = NULL;
init_pointers.c:	env->ymin = NULL;
init_pointers.c:	env->ymax = NULL;
init_pointers.c:	env->res[0] = NULL;
init_pointers.c:	env->res[1] = NULL;
init_pointers.c:	env->res[2] = NULL;
init_pointers.c:		env->textures[i].surface = NULL;
init_pointers.c:		env->textures[i].str = NULL;
init_pointers.c:		env->weapons[i].sound = NULL;
init_pointers.c:		env->weapons[i].empty = NULL;
init_pointers.c:	env->player.life = 100;
init_screen_pos.c:	env->screen_sectors_size = ft_min(env->nb_sectors, env->w);
init_screen_pos.c:	if (!(env->xmin = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
init_screen_pos.c:	if (!(env->xmax = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
init_screen_pos.c:	if (!(env->screen_sectors = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
init_screen_pos.c:	if (!(env->rendered_sectors = (short*)malloc(sizeof(short) * (env->screen_sectors_size))))
init_sdl.c:	if (!(env->sdl.window = SDL_CreateWindow(
init_sdl.c:					env->w,
init_sdl.c:					env->h,
init_sdl.c:	if (!(env->sdl.renderer = SDL_CreateRenderer(
init_sdl.c:					env->sdl.window,
init_sdl.c:	SDL_GetRendererInfo(env->sdl.renderer, &info);
init_sdl.c:	/*if (SDL_SetRenderDrawBlendMode(env->sdl.renderer, SDL_BLENDMODE_NONE))
init_sdl.c:	if (!(env->sdl.texture = SDL_CreateTexture(
init_sdl.c:					env->sdl.renderer,
init_sdl.c:					env->w,
init_sdl.c:					env->h)))
init_sdl.c:	if (!(env->sdl.texture_pixels = (Uint32*)malloc(sizeof(Uint32) * env->w * env->h)))
init_sdl.c:	if (!(env->depth_array = (double*)malloc(sizeof(double) * env->w * env->h)))
init_sdl.c:	if (!(env->ymin = (int*)malloc(sizeof(int) * env->w)))
init_sdl.c:	if (!(env->ymax = (int*)malloc(sizeof(int) * env->w)))
init_sdl.c:	if (!(env->screen_pos = (t_v2*)malloc(sizeof(t_v2) * (env->w))))
init_sdl.c:				env->sdl.renderer,
init_sdl.c:				env->sdl.texture,
init_sdl.c:	SDL_RenderPresent(env->sdl.renderer);
init_sdl.c:	env->time.milli_s =  0;
init_sound.c:	env->sound.b_jump = 20;
init_sound.c:	env->sound.b_footstep = 20;
init_sound.c:	env->sound.b_weapon = 20;
init_sound.c:	env->sound.g_music = 20;
init_sound.c:	if(!(env->sound.background = Mix_LoadMUS("audio/at_dooms_gate.mp3")))
init_sound.c:	if (!(env->sound.footstep = Mix_LoadWAV("audio/footstep.wav")))
init_sound.c:	if (!(env->sound.jump = Mix_LoadWAV("audio/jump.wav")))
init_sound.c:	if (!(env->weapons[0].sound = Mix_LoadWAV("audio/shotgun_shot.wav")))
init_sound.c:	if (!(env->weapons[0].empty = Mix_LoadWAV("audio/shotgun_no_ammo.wav")))
init_sound.c:	if (!(env->weapons[1].sound = Mix_LoadWAV("audio/raygun_shot.wav")))
init_sound.c:	if (!(env->weapons[1].empty = Mix_LoadWAV("audio/shotgun_no_ammo.wav")))
init_sound.c:	Mix_VolumeChunk(env->sound.jump, MIX_MAX_VOLUME / env->sound.b_jump);
init_sound.c:	Mix_VolumeChunk(env->sound.footstep, MIX_MAX_VOLUME / env->sound.b_footstep);
init_sound.c:	Mix_VolumeChunk(env->weapons[0].sound, MIX_MAX_VOLUME / env->sound.b_weapon);
init_sound.c:	Mix_VolumeChunk(env->weapons[1].sound, MIX_MAX_VOLUME / env->sound.b_weapon);
init_sprites.c:	if (!(env->sprites = (t_sprite*)malloc(sizeof(t_sprite) * 2)))
init_sprites.c:	env->sprites[0].texture = 33;
init_sprites.c:	env->sprites[0].oriented = 0;
init_sprites.c:	env->sprites[0].reversed[0] = 0;
init_sprites.c:	env->sprites[0].start[0].x = 511;
init_sprites.c:	env->sprites[0].start[0].y = 78;
init_sprites.c:	env->sprites[0].end[0].x = 562;
init_sprites.c:	env->sprites[0].end[0].y = 102;
init_sprites.c:	env->sprites[0].size[0].x = 51;
init_sprites.c:	env->sprites[0].size[0].y = 24;
init_sprites.c:	env->sprites[0].width = 2;
init_sprites.c:	env->sprites[0].height = 2;
init_sprites.c:	env->sprites[1].texture = 34;
init_sprites.c:	env->sprites[1].oriented = 1;
init_sprites.c:	env->sprites[1].width = 2;
init_sprites.c:	env->sprites[1].height = 2;
init_sprites.c:	env->sprites[1].start[0].x = 44;
init_sprites.c:	env->sprites[1].start[0].y = 120;
init_sprites.c:	env->sprites[1].end[0].x = 87;
init_sprites.c:	env->sprites[1].end[0].y = 165;
init_sprites.c:	env->sprites[1].size[0].x = 44;
init_sprites.c:	env->sprites[1].size[0].y = 46;
init_sprites.c:	env->sprites[1].reversed[0] = 0;
init_sprites.c:	env->sprites[1].start[1].x = 374;
init_sprites.c:	env->sprites[1].start[1].y = 120;
init_sprites.c:	env->sprites[1].end[1].x = 405;
init_sprites.c:	env->sprites[1].end[1].y = 172;
init_sprites.c:	env->sprites[1].size[1].x = 32;
init_sprites.c:	env->sprites[1].size[1].y = 53;
init_sprites.c:	env->sprites[1].reversed[1] = 0;
init_sprites.c:	env->sprites[1].start[2].x = 299;
init_sprites.c:	env->sprites[1].start[2].y = 120;
init_sprites.c:	env->sprites[1].end[2].x = 329;
init_sprites.c:	env->sprites[1].end[2].y = 173;
init_sprites.c:	env->sprites[1].size[2].x = 31;
init_sprites.c:	env->sprites[1].size[2].y = 54;
init_sprites.c:	env->sprites[1].reversed[2] = 0;
init_sprites.c:	env->sprites[1].start[3].x = 220;
init_sprites.c:	env->sprites[1].start[3].y = 120;
init_sprites.c:	env->sprites[1].end[3].x = 254;
init_sprites.c:	env->sprites[1].end[3].y = 171;
init_sprites.c:	env->sprites[1].size[3].x = 35;
init_sprites.c:	env->sprites[1].size[3].y = 52;
init_sprites.c:	env->sprites[1].reversed[3] = 0;
init_sprites.c:	env->sprites[1].start[4].x = 132;
init_sprites.c:	env->sprites[1].start[4].y = 120;
init_sprites.c:	env->sprites[1].end[4].x = 175;
init_sprites.c:	env->sprites[1].end[4].y = 165;
init_sprites.c:	env->sprites[1].size[4].x = 44;
init_sprites.c:	env->sprites[1].size[4].y = 46;
init_sprites.c:	env->sprites[1].reversed[4] = 0;
init_sprites.c:	env->sprites[1].start[5].x = 220;
init_sprites.c:	env->sprites[1].start[5].y = 120;
init_sprites.c:	env->sprites[1].end[5].x = 254;
init_sprites.c:	env->sprites[1].end[5].y = 171;
init_sprites.c:	env->sprites[1].size[5].x = 35;
init_sprites.c:	env->sprites[1].size[5].y = 52;
init_sprites.c:	env->sprites[1].reversed[5] = 1;
init_sprites.c:	env->sprites[1].start[6].x = 299;
init_sprites.c:	env->sprites[1].start[6].y = 120;
init_sprites.c:	env->sprites[1].end[6].x = 329;
init_sprites.c:	env->sprites[1].end[6].y = 173;
init_sprites.c:	env->sprites[1].size[6].x = 31;
init_sprites.c:	env->sprites[1].size[6].y = 54;
init_sprites.c:	env->sprites[1].reversed[6] = 1;
init_sprites.c:	env->sprites[1].start[7].x = 374;
init_sprites.c:	env->sprites[1].start[7].y = 120;
init_sprites.c:	env->sprites[1].end[7].x = 405;
init_sprites.c:	env->sprites[1].end[7].y = 172;
init_sprites.c:	env->sprites[1].size[7].x = 32;
init_sprites.c:	env->sprites[1].size[7].y = 53;
init_sprites.c:	env->sprites[1].reversed[7] = 1;
init_ttf.c:	//env->sdl.font = TTF_OpenFont("fonts/heartwrecked.ttf", 65);
init_ttf.c:	env->sdl.fonts.amazdoom70 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 70);
init_ttf.c:	env->sdl.fonts.amazdoom50 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 50);
init_ttf.c:	env->sdl.fonts.amazdoom20 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 20);
init_ttf.c:	env->sdl.fonts.alice30 = TTF_OpenFont("fonts/alice/Alice-Regular.ttf", 30);
init_ttf.c:	env->sdl.fonts.alice70 = TTF_OpenFont("fonts/alice/Alice-Regular.ttf", 70);
init_ttf.c:	env->sdl.fonts.bebasneue = TTF_OpenFont("fonts/bebas_neue/BebasNeue-Regular.ttf", 20);
init_weapons.c:	env->weapons[0].possessed = 1;
init_weapons.c:    env->weapons[0].weapon_switch = 0;
init_weapons.c:    env->weapons[0].first_sprite = 6;
init_weapons.c:    env->weapons[0].nb_sprites = 15;
init_weapons.c:    env->weapons[0].ammo = 20;
init_weapons.c:    env->weapons[0].no_ammo = 0;
init_weapons.c:    env->weapons[0].max_ammo = 20;
init_weapons.c:	env->weapons[1].possessed = 1;
init_weapons.c:    env->weapons[1].first_sprite = 21;
init_weapons.c:    env->weapons[1].nb_sprites = 7;
init_weapons.c:    env->weapons[1].ammo = 40;
init_weapons.c:    env->weapons[1].max_ammo = 40;
init_weapons.c:    env->weapons[1].no_ammo = 0;
inputs.c:	env->inputs.forward = 0;
inputs.c:	env->inputs.backward = 0;
inputs.c:	env->inputs.s = 0;
inputs.c:	env->inputs.left = 0;
inputs.c:	env->inputs.right = 0;
inputs.c:	env->inputs.plus = 0;
inputs.c:	env->inputs.minus = 0;
inputs.c:	env->inputs.shift = 0;
inputs.c:	env->inputs.ctrl = 0;
inputs.c:	env->inputs.space = 0;
inputs.c:	env->inputs.ctrl = 0;
inputs.c:	env->inputs.option = 0;
inputs.c:	env->inputs.left_click = 0;
inputs.c:	env->inputs.right_click = 0;
inputs.c:	env->inputs.enter = 0;
inputs.c:	env->inputs.up = 0;
inputs.c:	env->inputs.down = 0;
inputs.c:	if (env->button[nb].image == 30 || env->button[nb].image == 31)
inputs.c:		xmax = env->button[nb].x + 40;
inputs.c:		ymax = env->button[nb].y + 40;
inputs.c:		xmax = env->button[nb].x + 150;
inputs.c:		ymax = env->button[nb].y + 150;
inputs.c:	if ((env->sdl.mx >= env->button[nb].x
inputs.c:		&& env->sdl.mx <= xmax)
inputs.c:		&& (env->sdl.my >=  env->button[nb].y
inputs.c:		&& env->sdl.my <= ymax))
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.forward
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.forward2)
inputs.c:		env->inputs.forward = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.s
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.backward2)
inputs.c:		env->inputs.backward = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.left
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.left2)
inputs.c:		env->inputs.left = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.right
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.right2)
inputs.c:		env->inputs.right = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.plus)
inputs.c:		env->inputs.plus = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.minus)
inputs.c:		env->inputs.minus = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.shift)
inputs.c:		env->inputs.shift = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.space)
inputs.c:		env->inputs.space = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.ctrl)
inputs.c:		env->inputs.ctrl = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.up)
inputs.c:		env->inputs.up = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.down)
inputs.c:		env->inputs.down = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.option)
inputs.c:		env->inputs.option = mode;	
inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT)
inputs.c:		env->inputs.left_click = mode;
inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_RIGHT)
inputs.c:		env->inputs.right_click = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.enter)
inputs.c:		env->inputs.enter = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.s)
inputs.c:		env->inputs.s = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.backspace)
inputs.c:		env->inputs.backspace = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.del)
inputs.c:		env->inputs.del = mode;
inputs.c:	if (env->sdl.event.type == SDL_KEYDOWN)
inputs.c:	if (env->sdl.event.type == SDL_KEYUP)
inputs.c:	if (env->sdl.event.type == SDL_MOUSEBUTTONDOWN)
inputs.c:	if (env->sdl.event.type == SDL_MOUSEBUTTONUP)
intersections.c:	if (render->inter_left.x >= env->camera.far_left
intersections.c:			&& render->inter_left.x <= env->camera.near_left
intersections.c:			&& render->inter_left.y <= env->camera.far_z
intersections.c:			&& render->inter_left.y >= env->camera.near_z)
intersections.c:	if (render->vz1 < env->camera.near_z)
is_in_sector.c:	if (sector < 0 || sector >= env->nb_sectors)
is_in_sector.c:	if (pos.z < get_floor_at_pos(env->sectors[sector], new_v2(pos.x, pos.y), env)
is_in_sector.c:			|| pos.z > get_ceiling_at_pos(env->sectors[sector], new_v2(pos.x, pos.y), env))
is_in_sector.c:	while (i < env->sectors[sector].nb_vertices)
is_in_sector.c:		end_pos = (env->sectors[sector].x_max + 1 - SECTOR_X1) * (SECTOR_Y2 - SECTOR_Y1) - (pos.y - SECTOR_Y1) * (SECTOR_X2 - SECTOR_X1);
is_in_sector.c:	if (sector < 0 || sector >= env->nb_sectors)
is_in_sector.c:	while (i < env->sectors[sector].nb_vertices)
is_in_sector.c:		end_pos = (env->sectors[sector].x_max + 1 - SECTOR_X1) * (SECTOR_Y2 - SECTOR_Y1) - (pos.y - SECTOR_Y1) * (SECTOR_X2 - SECTOR_X1);
is_new_vertex_valid.c:	tmp = env->editor.current_vertices;
is_new_vertex_valid.c:					new_v2(round((env->sdl.mx - env->editor.center.x) / env->editor.scale),
is_new_vertex_valid.c:						round((env->sdl.my - env->editor.center.y) / env->editor.scale)),
is_new_vertex_valid.c:		v1 = env->vertices[sector.vertices[i]];
is_new_vertex_valid.c:		v2 = env->vertices[sector.vertices[i + 1]];
is_new_vertex_valid.c:					new_v2(round((env->sdl.mx - env->editor.center.x) / env->editor.scale),
is_new_vertex_valid.c:						round((env->sdl.my - env->editor.center.y) / env->editor.scale)),
is_new_vertex_valid.c:	tmp = env->editor.current_vertices;
is_new_vertex_valid.c:	tmp = env->editor.current_vertices;
is_new_vertex_valid.c:	while (i < env->nb_sectors)
is_new_vertex_valid.c:		if (check_sector_intersections(env, env->sectors[i], *last, index))
is_new_vertex_valid.c:	while (i < env->sectors[sector].nb_vertices)
is_new_vertex_valid.c:		if (env->sectors[sector].vertices[i] == env->editor.selected_vertex)
is_new_vertex_valid.c:	ret = env->sectors[sector].vertices[i];
is_new_vertex_valid.c:		last = env->vertices[env->sectors[list_sectors[i]].vertices[num + 1]];
is_new_vertex_valid.c:		while (j < env->nb_sectors)
is_new_vertex_valid.c:			if (check_sector_intersections(env, env->sectors[i], last, env->editor.selected_vertex))
is_new_vertex_valid.c:		last = env->vertices[env->sectors[list_sectors[i]].vertices[num - 1]];
is_new_vertex_valid.c:		while (j < env->nb_sectors)
is_new_vertex_valid.c:			if (check_sector_intersections(env, env->sectors[i], last, env->editor.selected_vertex))
is_new_vertex_valid.c:	if (!env->editor.current_vertices)
is_new_vertex_valid.c:	if (index != env->editor.start_vertex
keys.c:	if (!env->jump.on_going && env->inputs.space)
keys.c:	if (env->inputs.forward || env->inputs.backward || env->inputs.left
keys.c:			|| env->inputs.right)
keys.c:		Mix_PlayChannel(-1, env->sound.footstep, 0);
keys.c:	if (env->inputs.forward || env->inputs.backward || env->inputs.left
keys.c:			|| env->inputs.right || env->inputs.space || env->jump.on_going == 1
keys.c:			|| env->crouch.on_going || env->inputs.ctrl || env->gravity.on_going)
keys.c:	if (env->inputs.plus && !env->inputs.shift
keys.c:			&& env->options.minimap_scale * 1.2 < 100)
keys.c:		env->options.minimap_scale *= 1.2;
keys.c:	if (env->inputs.minus && !env->inputs.shift
keys.c:			&& env->options.minimap_scale / 1.2 > 5)
keys.c:		env->options.minimap_scale /= 1.2;
keys.c:	if (env->inputs.up && !env->inputs.shift)
keys.c:		env->sectors[env->player.sector].floor_slope += 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->player.sector]);
keys.c:		if (env->sectors[env->player.sector].floor_max
keys.c:			> env->sectors[env->player.sector].ceiling_min)
keys.c:			env->sectors[env->player.sector].floor_slope -= 0.01;
keys.c:			update_sector_slope(env, &env->sectors[env->player.sector]);
keys.c:	if (env->inputs.down && !env->inputs.shift)
keys.c:		env->sectors[env->player.sector].floor_slope -= 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->player.sector]);
keys.c:	if (env->inputs.up && env->inputs.shift)
keys.c:		env->sectors[env->player.sector].ceiling_slope += 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->player.sector]);
keys.c:	if (env->inputs.down && env->inputs.shift)
keys.c:		env->sectors[env->player.sector].ceiling_slope -= 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->player.sector]);
keys.c:		if (env->sectors[env->player.sector].floor_max
keys.c:			> env->sectors[env->player.sector].ceiling_min)
keys.c:			env->sectors[env->player.sector].ceiling_slope += 0.01;
keys.c:			update_sector_slope(env, &env->sectors[env->player.sector]);
keys.c:	if (env->inputs.right_click && !env->option)
keys.c:		if (env->weapons[env->player.curr_weapon].ammo < env->weapons[env->player.curr_weapon].max_ammo)
keys.c:			env->weapons[env->player.curr_weapon].ammo++;
map_init_objects.c:			env->nb_objects = ft_atoi(line);
map_init_objects.c:			if (env->nb_objects < 0)
map_init_objects.c:			if (env->nb_objects
map_init_objects.c:					&& !(env->objects = (t_object*)malloc(sizeof(t_object)
map_init_objects.c:							* (env->nb_objects))))
map_parse_objects.c:	env->objects[parser->objects_count].sprite = ft_atoi(*line);
map_parse_objects.c:	if (env->objects[parser->objects_count].sprite < 0
map_parse_objects.c:			|| env->objects[parser->objects_count].sprite >= MAX_SPRITES)
map_parse_objects.c:	env->objects[parser->objects_count].scale = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].pos.y = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].pos.x = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].pos.z = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].angle = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].sector = get_sector_global(env,
map_parse_objects.c:			new_v3(env->objects[parser->objects_count].pos.x,
map_parse_objects.c:				env->objects[parser->objects_count].pos.y,
map_parse_objects.c:				env->objects[parser->objects_count].pos.z));
map_parse_objects.c:	env->objects[parser->objects_count].light =
map_parse_objects.c:		env->sectors[env->objects[parser->objects_count].sector].light;
map_parse_objects.c:	while (parser->objects_count < env->nb_objects
map_parse_objects.c:					env->nb_objects - parser->objects_count);
map_parse_player.c:			env->player.pos.y = ft_atof(line);
map_parse_player.c:			env->player.pos.x = ft_atof(line);
map_parse_player.c:			env->player.angle = (ft_atof(line) + 0.00001) * CONVERT_RADIANS;
map_parse_player.c:			env->player.angle_cos = cos(env->player.angle);
map_parse_player.c:			env->player.angle_sin = sin(env->player.angle);
map_parse_player.c:			env->player.perp_cos = cos(env->player.angle - M_PI / 2);
map_parse_player.c:			env->player.perp_sin = sin(env->player.angle - M_PI / 2);
map_parse_player.c:			if ((env->player.sector = get_sector_no_z(env,
map_parse_player.c:							env->player.pos)) == -1)
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor = ft_atof(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_min = env->sectors[parser->
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_max = env->sectors[parser->
map_parse_sectors.c:		env->sectors[parser->sectors_count].floor_slope = ft_atof(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].floor_slope > 45
map_parse_sectors.c:			|| env->sectors[parser->sectors_count].floor_slope < -45)
map_parse_sectors.c:		env->sectors[parser->sectors_count].floor_slope = tan(env->
map_parse_sectors.c:		env->sectors[parser->sectors_count].floor_texture = ft_atoi(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].floor_texture < 0
map_parse_sectors.c:			|| env->sectors[parser->sectors_count].floor_texture >= MAX_TEXTURE)
map_parse_sectors.c:		env->sectors[parser->sectors_count].ceiling = ft_atof(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_min = env->sectors[parser->
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_max = env->sectors[parser->
map_parse_sectors.c:		env->sectors[parser->sectors_count].ceiling_slope = ft_atof(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling_slope > 45
map_parse_sectors.c:			|| env->sectors[parser->sectors_count].ceiling_slope < -45)
map_parse_sectors.c:		env->sectors[parser->sectors_count].ceiling_slope = tan(env->
map_parse_sectors.c:		env->sectors[parser->sectors_count].ceiling_texture = ft_atoi(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling_texture < 0 || env->
map_parse_sectors.c:	env->sectors[parser->sectors_count].nb_vertices = parser->
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].vertices = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].neighbors = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].textures = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].ceilings = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].floors = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_ceilings1 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_floors1 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_ceilings2 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_floors2 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].wall_width = (double*)
map_parse_sectors.c:		env->sectors[parser->sectors_count].vertices[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].vertices[i] < 0 || env->
map_parse_sectors.c:				sectors[parser->sectors_count].vertices[i] >= env->nb_vertices)
map_parse_sectors.c:					env->sectors[parser->sectors_count].vertices[i],
map_parse_sectors.c:	env->sectors[parser->sectors_count].vertices[parser->sector_vertices_count]
map_parse_sectors.c:		= env->sectors[parser->sectors_count].vertices[0];
map_parse_sectors.c:	if (check_vertices_uniqueness(env->sectors[parser->sectors_count]))
map_parse_sectors.c:	if (check_sector_duplicate(env, env->sectors[parser->sectors_count],
map_parse_sectors.c:		env->sectors[parser->sectors_count].neighbors[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].neighbors[i] < -1 || env->
map_parse_sectors.c:				sectors[parser->sectors_count].neighbors[i] >= env->nb_sectors)
map_parse_sectors.c:					env->sectors[parser->sectors_count].neighbors[i],
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].neighbors[i] == parser->sectors_count)
map_parse_sectors.c:		env->sectors[parser->sectors_count].textures[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].textures[i] < 0 || env->sectors[parser->sectors_count].textures[i] >= MAX_TEXTURE)
map_parse_sectors.c:					env->sectors[parser->sectors_count].textures[i],
map_parse_sectors.c:	env->sectors[parser->sectors_count].light = ft_atoi(*line) / 100.0;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].light < 0 ||
map_parse_sectors.c:			env->sectors[parser->sectors_count].light > 1)
map_parse_sectors.c:	env->sectors[parser->sectors_count].num = parser->sectors_count;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling
map_parse_sectors.c:			<= env->sectors[parser->sectors_count].floor)
map_parse_sectors.c:	while (parser->sectors_count < env->nb_sectors
map_parse_sectors.c:					env->nb_sectors - parser->sectors_count);
map_parse_sectors_utils.c:		current = env->sectors[i];
map_parse_sectors_utils.c:		if (sector_eq(sector, env->sectors[i]))
map_parse_vertices.c:		if (vertex.x == env->vertices[i].x && vertex.y == env->vertices[i].y)
map_parse_vertices.c:	env->vertices[parser->vertices_count].num = parser->vertices_count;
map_parse_vertices.c:	env->vertices[parser->vertices_count].y = ft_atof(line);
map_parse_vertices.c:	env->vertices[parser->vertices_count].x = ft_atof(line);
map_parse_vertices.c:	if (check_vertex_duplicate(env, env->vertices[parser->vertices_count],
map_parse_vertices.c:	while (parser->vertices_count < env->nb_vertices
map_parse_vertices.c:					env->nb_vertices - parser->vertices_count);
map_parser.c:				env->nb_vertices = ft_atoi(line);
map_parser.c:				if (env->nb_vertices < 3)
map_parser.c:			if (!(env->vertices = (t_vertex *)malloc(sizeof(t_vertex)
map_parser.c:							* (env->nb_vertices))))
map_parser.c:				env->nb_sectors = atoi(line);
map_parser.c:				if (env->nb_sectors < 1)
map_parser.c:			if (!(env->sectors = (t_sector *)malloc(sizeof(t_sector)
map_parser.c:							* (env->nb_sectors))))
map_parser.c:			while (i < env->nb_sectors)
map_parser.c:				ft_bzero(&env->sectors[i], sizeof(t_sector));
map_parser.c:				env->sectors[i].x_max = -2147483648;
map_parser.c:	while (i < env->nb_sectors)
map_parser.c:		while (j < env->sectors[i].nb_vertices)
map_parser.c:			if (env->sectors[i].x_max
map_parser.c:					< env->vertices[env->sectors[i].vertices[j]].x)
map_parser.c:				env->sectors[i].x_max =
map_parser.c:					env->vertices[env->sectors[i].vertices[j]].x;
map_parser.c:	env->player.eyesight = 6;
map_parser.c:	env->player.sector = -1;
map_parser.c:	env->player.angle_z_cos = cos(0);
map_parser.c:	env->player.angle_z_sin = sin(0);
map_parser.c:	env->player.speed = 0.5;
map_parser.c:	env->player.pos.z = 0;
map_parser.c:	env->nb_sectors = 0;
map_parser.c:	env->nb_vertices = 0;
map_parser.c:	if (env->player.sector == -1)
maths_utils.c:	sector = env->sectors[env->player.sector];
maths_utils.c:	v0 = env->vertices[sector.vertices[0]];
maths_utils.c:	env->player.pos.z =
maths_utils.c:		(sector.normal.x * (env->player.pos.x - v0.x)
maths_utils.c:		 - sector.normal.y * (env->player.pos.y - v0.y)) * sector.floor_slope;
maths_utils.c:	env->player.head_z = env->player.pos.z + env->player.eyesight;
maths_utils.c:	sector = env->sectors[env->player.sector];
maths_utils.c:	v0 = env->vertices[sector.vertices[0]];
maths_utils.c:		(sector.normal.x * (env->player.pos.x - v0.x)
maths_utils.c:		 - sector.normal.y * (env->player.pos.y - v0.y)) * sector.floor_slope;
maths_utils.c:	env->gravity.floor = player_feet;
menu_tools.c:	while (xx < env->textures[i].surface->w && xx < env->w)
menu_tools.c:		while (yy < env->textures[i].surface->h && yy < env->h)
menu_tools.c:			if (env->textures[i].str[xx + env->textures[i].surface->w * yy] != 0xFFC10099)
menu_tools.c:				env->sdl.texture_pixels[(x + (y * env->w)) + xx + env->w * yy] = env->textures[i].str[xx + env->textures[i].surface->w * yy];
menu_tools.c:	env->button[ref_but].x = x;
menu_tools.c:	env->button[ref_but].y = y;
menu_tools.c:	env->button[ref_but].image = text;
menu_tools.c:	env->button[ref_but].id = ref_but;
minimap.c:	pixels = env->sdl.texture_pixels;
minimap.c:	if (x >= env->w - 300 && x < env->w && y >= 0 && y <= 300)
minimap.c:		if (color == 0xFFFF0000 || (pixels[x + env->w * y] != 0xFF00FF00
minimap.c:			&& pixels[x + env->w * y] != 0xFFFFFFF))
minimap.c:			if (x >= 0 && x < env->w && y >= 0 && y <= env->h)
minimap.c:				pixels[x + env->w * y] = color;
minimap.c:	start = new_point(env->w - 150, 150);
minimap.c:	x = env->w - 152;
minimap.c:	while (x < env->w - 147)
minimap.c:			(env->player.near_left.x - env->player.pos.x) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.near_left.y - env->player.pos.y) * env->options.minimap_scale + 150,
minimap.c:			(env->player.angle_cos * env->camera.far_z - env->player.angle_sin * env->camera.far_left) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.angle_sin * env->camera.far_z + env->player.angle_cos * env->camera.far_left) * env->options.minimap_scale + 150,
minimap.c:			(env->player.near_right.x - env->player.pos.x) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.near_right.y - env->player.pos.y) * env->options.minimap_scale + 150,
minimap.c:	if (!env->options.test)
minimap.c:			(env->player.angle_cos * env->camera.far_z - env->player.angle_sin * env->camera.far_right) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.angle_sin * env->camera.far_z + env->player.angle_cos * env->camera.far_right) * env->options.minimap_scale + 150,
minimap.c:	p0.x = env->player.angle_cos * env->camera.near_z * env->options.minimap_scale + start.x;
minimap.c:	p0.y = env->player.angle_sin * env->camera.near_z * env->options.minimap_scale + 150;
minimap.c:	p1.x = p0.x + env->player.perp_cos * env->w * env->options.minimap_scale;
minimap.c:	p1.y = p0.y + env->player.perp_sin * env->w * env->options.minimap_scale;
minimap.c:	p0.x = p0.x - env->player.perp_cos * env->w * env->options.minimap_scale;
minimap.c:	p0.y = p0.y - env->player.perp_sin * env->w * env->options.minimap_scale;
minimap.c:	if (env->options.test)
minimap.c:	p1.x = env->player.angle_cos * env->camera.near_z * env->options.minimap_scale + p0.x;
minimap.c:	p1.y = env->player.angle_sin * env->camera.near_z * env->options.minimap_scale + p0.y;
minimap.c:	max = env->w;
minimap.c:	if (sector.num == env->player.sector)
minimap.c:	start = new_point(env->w - 150, 150);
minimap.c:		pos.x += start.x + (env->vertices[sector.vertices[i]].x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:		pos.y += start.y + (env->vertices[sector.vertices[i]].y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:	if (pos.x > env->w - 297 && pos.x < env->w && pos.y <= 295 && pos.y >= 0)
minimap.c:					env->sdl.fonts.bebasneue,
minimap.c:	pixels = env->sdl.texture_pixels;
minimap.c:	while (++i < env->nb_objects)
minimap.c:		object = env->objects[i];
minimap.c:		pos.x = env->w - 150 + (object.pos.x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:			pos.y = 150 + (object.pos.y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:				if (x > env->w - 300 && x < env->w && y >= 0 && y < 300)
minimap.c:					pixels[x + y * env->w] = 0xFFFF0000;
minimap.c:	start.x = env->w - 150;
minimap.c:	while (s < env->nb_sectors)
minimap.c:		sect = env->sectors[s];
minimap.c:		if (env->player.head_z > sect.floor_min
minimap.c:				&& env->player.head_z < sect.ceiling_max)
minimap.c:			if (s == env->player.sector)
minimap.c:				line.p0.x = start.x + (env->vertices[sect.vertices[v]].x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:				line.p0.y = start.y + (env->vertices[sect.vertices[v]].y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:				line.p1.x = start.x + (env->vertices[sect.vertices[v + 1]].x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:				line.p1.y = start.y + (env->vertices[sect.vertices[v + 1]].y - env->player.pos.y) * env->options.minimap_scale;
movement.c:	env->player.camera_x = env->player.pos.x + env->player.angle_cos * env->camera.near_z;
movement.c:	env->player.camera_y = env->player.pos.y + env->player.angle_sin * env->camera.near_z;
movement.c:	env->player.near_left.x = env->player.pos.x + (env->player.angle_cos * env->camera.near_z - env->player.angle_sin * env->camera.near_left);
movement.c:	env->player.near_left.y = env->player.pos.y + (env->player.angle_sin * env->camera.near_z + env->player.angle_cos * env->camera.near_left);
movement.c:	env->player.near_right.x = env->player.pos.x + (env->player.angle_cos * env->camera.near_z - env->player.angle_sin * env->camera.near_right);
movement.c:	env->player.near_right.y = env->player.pos.y + (env->player.angle_sin * env->camera.near_z + env->player.angle_cos * env->camera.near_right);
movement.c:	if (env->gravity.on_going)
movement.c:	if (((env->inputs.space && !env->player.state) || env->jump.on_going))
movement.c:	if (((env->inputs.ctrl && !env->player.state && env->player.eyesight == 6) || env->crouch.on_going) && !env->jump.on_going)
movement.c:	env->time.end = env->time.milli_s / 10;
movement.c:	if (env->time.end - env->time.start >= 1)
movement.c:		env->time.start = env->time.end;
movement.c:		if (env->inputs.forward && !env->inputs.backward)
movement.c:			if (check_collision(env, env->player.angle_cos * env->player.speed, env->player.angle_sin * env->player.speed))
movement.c:				env->player.pos.x += env->player.angle_cos * env->player.speed;
movement.c:				env->player.pos.y += env->player.angle_sin * env->player.speed;
movement.c:		else if (env->inputs.backward && !env->inputs.forward)
movement.c:			if (check_collision(env, env->player.angle_cos * -env->player.speed, env->player.angle_sin * -env->player.speed))
movement.c:				env->player.pos.x -= env->player.angle_cos * env->player.speed;
movement.c:				env->player.pos.y -= env->player.angle_sin * env->player.speed;
movement.c:		if (env->inputs.left && !env->inputs.right)
movement.c:			if (check_collision(env, env->player.angle_sin * env->player.speed, env->player.angle_cos * -env->player.speed))
movement.c:				env->player.pos.x += env->player.angle_sin * env->player.speed;
movement.c:				env->player.pos.y -= env->player.angle_cos * env->player.speed;
movement.c:		else if (env->inputs.right && !env->inputs.left)
movement.c:			if (check_collision(env, env->player.angle_sin * -env->player.speed, env->player.angle_cos * env->player.speed))
movement.c:				env->player.pos.x -= env->player.angle_sin * env->player.speed;
movement.c:				env->player.pos.y += env->player.angle_cos * env->player.speed;
movement_collision.c:    motion.old_sector = env->player.sector;
movement_collision.c:    FUTURE_Z = env->player.eyesight + env->sectors[env->player.sector].floor + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].floor_slope;
movement_collision.c:    if (FUTURE_Z > env->sectors[env->player.sector].ceiling + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].ceiling_slope - 1)
movement_collision.c:    FUTURE_Z = env->sectors[env->player.sector].floor + (env->sectors[env->player.sector].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[env->player.sector].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[env->player.sector].floor_slope;
movement_collision.c:    if (FUTURE_Z > env->player.pos.z + 2)
movement_collision.c:    env->sector_list[wall.sector_dest] = 1;
movement_collision.c:    sector_tmp = env->player.sector;
movement_collision.c:    env->player.sector = wall.sector_dest;
movement_collision.c:        env->player.sector = sector_tmp;
movement_collision.c:    env->player.sector = sector_tmp;
movement_collision.c:    while (i < env->sectors[wall.sector_dest].nb_vertices)
movement_collision.c:            env->sector_list[RNEIGHBOR] == 0)
movement_collision.c:    if (env->options.wall_lover == 1)
movement_collision.c:    while (i < env->nb_sectors)
movement_collision.c:        if (i == env->player.sector)
movement_collision.c:            env->sector_list[i] = 1;
movement_collision.c:            env->sector_list[i] = 0;
movement_collision.c:    FUTURE_X = env->player.pos.x + x_move;
movement_collision.c:    FUTURE_Y = env->player.pos.y + y_move;
movement_collision.c:    while (i < env->sectors[env->player.sector].nb_vertices)
movement_collision.c:        motion.old_sector = env->player.sector;
movement_collision.c:            wall.sector_or = env->player.sector;
movement_collision.c:                while (j < env->nb_sectors)
movement_collision.c:                    if (env->sector_list[j])
movement_collision.c:                            sector_tmp = env->player.sector;
movement_collision.c:                            env->player.sector = j;
movement_collision.c:                                env->player.sector = sector_tmp;
movement_collision.c:                            j = env->nb_sectors;
movement_collision.c:    while (i < env->nb_objects)
movement_collision.c:        if (env->objects[i].exists && distance_two_points(env->objects[i].pos.x, env->objects[i].pos.y, PLAYER_XPOS, PLAYER_YPOS) < 1.75
movement_collision.c:            /* && (ft_abs(env->player.pos.z - env->objects[i].pos.z) <= 2 || ft_abs(env->player.head_z - env->objects[i].pos.z) <= 2) */)
movement_collision.c:            if (env->objects[i].sprite == 0 && env->weapons[env->player.curr_weapon].ammo < env->weapons[env->player.curr_weapon].max_ammo)
movement_collision.c:                env->weapons[env->player.curr_weapon].ammo += 10;
movement_collision.c:                    env->objects[i].exists = 0;
movement_collision.c:                if (env->weapons[env->player.curr_weapon].ammo >= env->weapons[env->player.curr_weapon].max_ammo)
movement_collision.c:                    env->weapons[env->player.curr_weapon].ammo = env->weapons[env->player.curr_weapon].max_ammo;
movement_collision.c:            else if (env->objects[i].sprite == 1)
movement_collision.c:                env->player.life -= 15;
movement_collision.c:                env->objects[i].exists = 0;
objects_selection.c:	if (env->inputs.left_click
objects_selection.c:			&& env->sdl.mx > 80
objects_selection.c:			&& env->sdl.mx < 120
objects_selection.c:			&& env->sdl.my > 280
objects_selection.c:			&& env->sdl.my < 320
objects_selection.c:			&& env->editor.start_vertex == -1
objects_selection.c:			&& env->editor.selected_player == -1
objects_selection.c:			&& env->editor.selected_vertex == -1
objects_selection.c:			&& env->editor.selected_object == -1)
objects_selection.c:		env->editor.selected_object = env->nb_objects;
objects_selection.c:	if (!env->inputs.left_click && env->editor.selected_object != -1)
objects_selection.c:		if (env->sdl.mx > 200)
objects_selection.c:			if (env->editor.selected_object == env->nb_objects)
objects_selection.c:				env->nb_objects++;
objects_selection.c:				env->objects[env->editor.selected_object].pos.x =	(env->sdl.mx - env->editor.center.x) / env->editor.scale;
objects_selection.c:				env->objects[env->editor.selected_object].pos.y =	(env->sdl.my - env->editor.center.y) / env->editor.scale;
objects_selection.c:			delete_object(env, env->editor.selected_object);
objects_selection.c:		env->editor.selected_object = -1;
options.c:	env->screen_w[2] = 2560;
options.c:	env->screen_h[2] = 1440;
options.c:	env->screen_w[1] = 1920;
options.c:	env->screen_h[1] = 1080;
options.c:	env->screen_w[0] = 1600;
options.c:	env->screen_h[0] = 900;
options.c:	if (!(env->res[2] = ft_strdup("2560 x 1440")))
options.c:	if (!(env->res[1] = ft_strdup("1920 x 1080")))
options.c:	if (!(env->res[0] = ft_strdup("1600 x 900")))
options.c:	env->w = env->screen_w[env->i];
options.c:	env->h = env->screen_h[env->i];
options.c:	env->h_w = env->w / 2;
options.c:	env->h_h = env->h / 2;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_c)
options.c:		env->options.contouring = env->options.contouring ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_r)
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_l)
options.c:		env->options.lighting = env->options.lighting ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_m)
options.c:		env->options.show_minimap = env->options.show_minimap ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_f)
options.c:		env->options.show_fps = env->options.show_fps ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_x)
options.c:		env->options.wall_lover = env->options.wall_lover ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_j)
options.c:		env->options.color_clipping = env->options.color_clipping ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_g)
options.c:		env->options.wall_color = env->options.wall_color ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_t)
options.c:		env->options.test = env->options.test ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_i)
options.c:		env->options.clipping = env->options.clipping ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_n)
options.c:		env->drawing = env->drawing ? 0 : 1;
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_o)
options.c:		env->option = env->option ? 0 : 1;
options.c:		if (env->option)
options.c:	if (env->sdl.event.key.keysym.sym == SDLK_TAB)
options.c:		env->options.zbuffer = env->options.zbuffer ? 0 : 1;
options.c:	add_button(env, 30, env->h_w - 40, env->h_h - 200, 2);
options.c:	add_button(env, 31, env->h_w + 160, env->h_h - 200, 3);
options.c:	print_text(new_point(env->h_h - 200, env->h_w - 250), new_printable_text("Resolution :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	print_text(new_point(env->h_h - 200 , env->h_w + 5), new_printable_text(env->res[env->i], env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	sound = ft_sitoa(env->sound.g_music);
options.c:	add_button(env, 30, env->h_w - 40, env->h_h - 100, 4);
options.c:	add_button(env, 31, env->h_w + 160, env->h_h - 100, 5);
options.c:	print_text(new_point(env->h_h - 100 , env->h_w - 250), new_printable_text("Sound :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	print_text(new_point(env->h_h - 100 , env->h_w + 65), new_printable_text(sound, env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	add_button(env, 0, env->h_w + 350, env->h_h + 350, 1);
options.c:	print_text(new_point(env->h / 4 - 100, env->h_w - 250), new_printable_text("PARAMETERS", env->sdl.fonts.alice70, 0x960018FF, 70), env);
options.c:	print_text(new_point(env->h_h + 350 , env->h_w + 350), new_printable_text("APPLIQUER", env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	print_text(new_point(env->h_h, env->h_w - 250), new_printable_text("Select menu :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	print_text(new_point(env->h_h, env->h_w + 65), new_printable_text("GO", env->sdl.fonts.alice30, 0x960018FF, 30), env);
options.c:	add_button(env, 0, env->h_w + 65, env->h_h, 7);
options.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT && env->option)
options.c:		if (env->inputs.left_click
options.c:				&& env->i > 0)
options.c:			env->i--;
options.c:		else if (env->inputs.left_click
options.c:				&& env->i < 2)
options.c:			env->i++;
options.c:		else if (env->inputs.left_click
options.c:				&& env->sound.g_music > 5)
options.c:			env->sound.g_music -= 5;
options.c:		else if (env->inputs.left_click
options.c:				&& env->sound.g_music < 100)
options.c:			env->sound.g_music += 5;
options.c:		else if (env->inputs.left_click
options.c:			env->aplicate_changes = 1;
options.c:	if (env->aplicate_changes)
options.c:		env->aplicate_changes = 0;
physics.c:	new_time = env->time.milli_s;
physics.c:	env->time.milli_s = SDL_GetTicks();
physics.c:	env->player.speed = ((env->time.milli_s - new_time) / 1000) * 15;
physics.c:	env->player.rotation_speed = ((env->time.milli_s - new_time) / 1000) * 0.2;
physics.c:	env->time.tenth_s = env->time.milli_s / 100;
physics.c:	env->jump.on_going = 1;
physics.c:	env->gravity.on_going = 0;
physics.c:	env->player.state = 1;
physics.c:	new_time = env->time.milli_s;
physics.c:		if (!env->jump.start)
physics.c:			//Mix_PlayChannel(1, env->sound.jump, 0);
physics.c:			env->jump.start = env->time.milli_s;
physics.c:			env->jump.height = env->player.pos.z + 3;
physics.c:		if (env->player.pos.z <= env->jump.height)
physics.c:			env->player.pos.z = env->jump.height - 3;
physics.c:			env->player.head_z = env->player.pos.z + env->player.eyesight;
physics.c:			env->jump.tick = env->jump.end / env->jump.nb_frame;
physics.c:			j = (new_time - env->jump.start) / env->jump.tick;
physics.c:				res += x - env->gravity.weight;
physics.c:				env->gravity.weight += 0.04;
physics.c:			env->gravity.weight = 0;	
physics.c:			env->player.pos.z += res;
physics.c:			env->player.head_z = env->player.pos.z + env->player.eyesight;
physics.c:			if (env->gravity.weight < 0)
physics.c:				env->gravity.weight = 0;
physics.c:		if (new_time - env->jump.start >= env->jump.end)
physics.c:			env->gravity.weight = 0;
physics.c:			env->gravity.on_going = 1;
physics.c:			env->jump.start = 0;
physics.c:			env->jump.on_going = 0;
physics.c:			env->player.state = 0;
physics.c:	if (env->flag)
physics.c:		env->flag = 0;
physics.c:	if (env->player.pos.z < env->gravity.floor)
physics.c:		if (env->player.pos.z + x > env->gravity.floor)
physics.c:			x = env->gravity.floor - env->player.pos.z;
physics.c:			env->player.pos.z += x;
physics.c:		else if (env->player.pos.z < env->gravity.floor)
physics.c:			env->player.pos.z += (x);
physics.c:		else if (env->player.pos.z + (x) > env->gravity.floor)
physics.c:			x = env->gravity.floor - env->player.pos.z;
physics.c:			env->player.pos.z += x;
physics.c:		if (env->player.pos.z == env->gravity.floor)
physics.c:			env->player.state = 0;
physics.c:	else if (env->player.eyesight < 6)
physics.c:		env->player.eyesight += 0.5;
physics.c:	env->player.head_z = env->player.pos.z + env->player.eyesight;
physics.c:	env->gravity.start = env->time.tenth_s;
physics.c:	env->player.state = 1;
physics.c:	env->gravity.end = env->gravity.start;
physics.c:	if (env->player.pos.z > env->gravity.floor && env->player.pos.z -
physics.c:			(x * env->gravity.weight) < env->gravity.floor)
physics.c:		x = env->player.pos.z - env->gravity.floor;
physics.c:		env->player.pos.z -= x;
physics.c:		env->gravity.weight = 1;
physics.c:		env->player.state = 0;
physics.c:		env->flag = 0;
physics.c:	else if (env->player.pos.z > env->gravity.floor)
physics.c:		env->player.pos.z -= (x * env->gravity.weight);
physics.c:		env->gravity.weight += 0.1;
physics.c:	else if ((env->player.pos.z > env->gravity.floor && env->player.pos.z -
physics.c:				(x * env->gravity.weight) < env->gravity.floor) || env->player.pos.z == env->gravity.floor)
physics.c:		x = env->player.pos.z - env->gravity.floor;
physics.c:		env->player.pos.z -= x;
physics.c:		env->gravity.weight = 1;
physics.c:		env->player.state = 0;
physics.c:		env->flag = 0;
physics.c:	env->player.head_z = env->player.pos.z + env->player.eyesight;
physics.c:	new_time = env->time.milli_s;
physics.c:	env->crouch.on_going = 1;
physics.c:	if (!env->crouch.start)
physics.c:		env->crouch.start = env->time.milli_s;
physics.c:	if (env->player.eyesight > 3)
physics.c:		i = (new_time - env->crouch.start) / env->crouch.tick;
physics.c:		if (i > env->crouch.nb_frame)
physics.c:			i = env->crouch.nb_frame;
physics.c:		env->player.eyesight = (6 - (x * i));
physics.c:	if (env->player.eyesight == 3)
physics.c:		env->player.state = 0;
physics.c:		env->crouch.start = 0;
physics.c:		env->crouch.on_going = 0;
physics.c:	env->player.head_z = env->player.pos.z + env->player.eyesight;
physics.c:	double	p_z = env->player.pos.z;
physics.c:	if (p_z != env->gravity.floor || env->player.eyesight != 6)
physics.c:		if (p_z > env->gravity.floor && !env->jump.on_going)
physics.c:			env->flag = 1;
physics.c:		else if ((env->player.pos.z < env->gravity.floor && !env->jump.on_going)
physics.c:				|| ((env->player.eyesight < 6) && !env->inputs.ctrl))
player_selection.c:	if (env->inputs.left_click
player_selection.c:			&& env->sdl.mx > 80
player_selection.c:			&& env->sdl.mx < 120
player_selection.c:			&& env->sdl.my > 180
player_selection.c:			&& env->sdl.my < 220
player_selection.c:			&& env->editor.start_vertex == -1
player_selection.c:			&& env->editor.selected_player == -1
player_selection.c:			&& env->editor.selected_vertex == -1
player_selection.c:			&& env->editor.selected_object == -1)
player_selection.c:		env->editor.selected_player = 1;
player_selection.c:	if (!env->inputs.left_click && env->editor.selected_player == 1)
player_selection.c:		env->editor.selected_player = -1;
player_selection.c:		if (env->sdl.mx > 200)
player_selection.c:			env->editor.new_player = 1;
player_selection.c:			env->editor.new_player = 0;
print_debug.c:	h = env->h;
print_debug.c:	player_sector = ft_sitoa(env->player.sector);
print_debug.c:	print_text(new_point(h - 150, 5), new_printable_text("Player sector = ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_debug.c:	print_text(new_point(h - 150, 215), new_printable_text(player_sector, env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_debug.c:	print_text(new_point(0, 1300), new_printable_text("Test", env->sdl.fonts.alice30, 0xFFFFFFFF, 20), env);
print_debug.c:	print_text(new_point(h - 200, 5), new_printable_text("Clipping :", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_debug.c:	if (env->options.clipping)
print_debug.c:		print_text(new_point(h - 200, 145), new_printable_text("ON", env->sdl.fonts.alice30, 0x00FF00FF, 30), env);
print_debug.c:		print_text(new_point(h - 200, 145), new_printable_text("OFF", env->sdl.fonts.alice30, 0xFF0000FF, 30), env);
raycasting.c:	sector = env->sectors[render.sector];
raycasting.c:		//render.current_ceiling = ft_clamp(render.max_ceiling, 0, env->h - 1);
raycasting.c:		render.current_ceiling = ft_clamp(render.max_ceiling, env->ymin[x], env->ymax[x]);
raycasting.c:		//render.current_floor = ft_clamp(render.max_floor, 0, env->h - 1);
raycasting.c:		render.current_floor = ft_clamp(render.max_floor, env->ymin[x], env->ymax[x]);
raycasting.c:		if (render.current_floor < env->h)
raycasting.c:			env->ymin[x] = ft_clamp(
raycasting.c:					env->ymin[x],
raycasting.c:					env->ymax[x]);
raycasting.c:			env->ymax[x] = ft_clamp(
raycasting.c:					env->ymin[x],
raycasting.c:					env->ymax[x]);
raycasting.c:			if ((env->options.zbuffer || env->options.contouring)
raycasting.c:	if (!env->options.wall_color && THREADS == 1)
raycasting.c:		if (!env->inputs.shift)
render.c:	v = env->vertices[sector.vertices[i]];
render.c:	env->vertices[sector.vertices[i]].clipped_x[0] = render.clipped_vx1 * env->player.angle_sin
render.c:		+ render.clipped_vz1 * env->player.angle_cos;
render.c:	env->vertices[sector.vertices[i]].clipped_y[0] = render.clipped_vx1 * -env->player.angle_cos
render.c:		+ render.clipped_vz1 * env->player.angle_sin;
render.c:	env->vertices[sector.vertices[i]].clipped_x[0] += env->player.pos.x;
render.c:	env->vertices[sector.vertices[i]].clipped_y[0] += env->player.pos.y;
render.c:	env->vertices[sector.vertices[i]].clipped[0] = 1;
render.c:		env->sectors[render.sector].clipped_floors1[i] = get_floor_at_pos(sector,
render.c:		env->sectors[render.sector].clipped_ceilings1[i] = get_ceiling_at_pos(sector,
render.c:	v = env->vertices[sector.vertices[i + 1]];
render.c:	env->vertices[sector.vertices[i + 1]].clipped_x[1] = render.clipped_vx2 * env->player.angle_sin
render.c:		+ render.clipped_vz2 * env->player.angle_cos;
render.c:	env->vertices[sector.vertices[i + 1]].clipped_y[1] = render.clipped_vx2 * -env->player.angle_cos
render.c:		+ render.clipped_vz2 * env->player.angle_sin;
render.c:	env->vertices[sector.vertices[i + 1]].clipped_x[1] += env->player.pos.x;
render.c:	env->vertices[sector.vertices[i + 1]].clipped_y[1] += env->player.pos.y;
render.c:	env->vertices[sector.vertices[i + 1]].clipped[1] = 1;
render.c:		env->sectors[render.sector].clipped_floors1[i + 1] = get_floor_at_pos(sector,
render.c:		env->sectors[render.sector].clipped_ceilings1[i + 1] = get_ceiling_at_pos(sector,
render.c:	if (!env->rendered_sectors[render.sector])
render.c:		env->rendered_sectors[render.sector]++;
render.c:		sector = env->sectors[render.sector];
render.c:			render.floor_yscale = env->textures[render.floor_texture].surface->h / 5.0;
render.c:			render.floor_xscale = env->textures[render.floor_texture].surface->w / 5.0;
render.c:			render.ceiling_yscale = env->textures[render.ceiling_texture].surface->h / 5.0;
render.c:			render.ceiling_xscale = env->textures[render.ceiling_texture].surface->w / 5.0;
render.c:					if (sector.neighbors[i] >= 0 && sector.neighbors[i] != env->player.sector
render.c:					   && !env->rendered_sectors[sector.neighbors[i]])
render.c:						render.nv1 = get_vertex_nb_in_sector(sector.vertices[i], env->sectors[sector.neighbors[i]]);
render.c:						render.nv2 = get_vertex_nb_in_sector(sector.vertices[i + 1], env->sectors[sector.neighbors[i]]);
render.c:						project_neighbor_floor_and_ceiling(&render, env, env->sectors[sector.neighbors[i]]);
render.c:					render.x1z1 = env->vertices[sector.vertices[i]].x / render.vz1;
render.c:					render.x2z2 = env->vertices[sector.vertices[i + 1]].x / render.vz2;
render.c:					render.y1z1 = env->vertices[sector.vertices[i]].y / render.vz1;
render.c:					render.y2z2 = env->vertices[sector.vertices[i + 1]].y / render.vz2; 
render.c:						render.projected_texture_w = env->textures[render.texture].surface->w
render.c:						render.projected_texture_w = env->textures[render.texture].surface->w
render.c:					render.projected_texture_h = env->textures[render.texture].surface->h
render.c:		env->rendered_sectors[render.sector]--;
render.c:	max = env->screen_sectors_size;
render.c:	ymin = ft_max(env->h_h + env->camera.y1 * env->camera.scale, 0);
render.c:	ymax = ft_min(env->h_h + env->camera.y2 * env->camera.scale, env->h - 1);
render.c:		env->xmin[i] = -1;
render.c:		env->xmax[i] = -1;
render.c:		env->screen_sectors[i] = -1;
render.c:	while (i < env->nb_sectors)
render.c:		env->rendered_sectors[i] = 0;
render.c:	while (i < env->w)
render.c:		env->ymin[i] = ymin;
render.c:		env->ymax[i] = ymax;
render.c:	while (i < env->nb_objects)
render.c:		env->objects[i].seen = 0;
render.c:	env->count = 0;
render.c:		render.xmin = env->xmin[i];
render.c:		render.xmax = env->xmax[i];
render.c:		render.sector = env->screen_sectors[i];
render_maths.c:		render->v1.x = env->vertices[sector.vertices[i]].x - env->player.pos.x;
render_maths.c:		render->v1.z = env->vertices[sector.vertices[i]].y - env->player.pos.y;
render_maths.c:	render->v2.x = env->vertices[sector.vertices[i + 1]].x - env->player.pos.x;
render_maths.c:	render->v2.z = env->vertices[sector.vertices[i + 1]].y - env->player.pos.y;
render_maths.c:		render->vx1 = render->v1.x * env->player.angle_sin - render->v1.z * env->player.angle_cos;
render_maths.c:		render->vz1 = render->v1.x * env->player.angle_cos + render->v1.z * env->player.angle_sin;
render_maths.c:	render->vx2 = render->v2.x * env->player.angle_sin - render->v2.z * env->player.angle_cos;
render_maths.c:	render->vz2 = render->v2.x * env->player.angle_cos + render->v2.z * env->player.angle_sin;
render_maths.c:	render->preclip_angle_z1 = render->vz1 * env->player.angle_z;
render_maths.c:	render->preclip_angle_z2 = render->vz2 * env->player.angle_z;
render_maths.c:	render->angle_z1 = render->clipped_vz1 * env->player.angle_z;
render_maths.c:	render->angle_z2 = render->clipped_vz2 * env->player.angle_z;
render_maths.c:	y1 = sector.clipped_floors1[i] - env->player.head_z;
render_maths.c:	y2 = sector.clipped_floors2[i + 1] - env->player.head_z;
render_maths.c:	y1 = sector.clipped_ceilings1[i] - env->player.head_z;
render_maths.c:	y2 = sector.clipped_ceilings2[i + 1] - env->player.head_z;
render_maths.c:	y1 = sector.floors[i] - env->player.head_z;
render_maths.c:	y2 = sector.floors[i + 1] - env->player.head_z;
render_maths.c:	y1 = sector.ceilings[i] - env->player.head_z;
render_maths.c:	y2 = sector.ceilings[i + 1] - env->player.head_z;
render_maths.c:	y1 = neighbor.clipped_floors1[render->nv1] - env->player.head_z;
render_maths.c:	y2 = neighbor.clipped_floors2[render->nv2] - env->player.head_z;
render_maths.c:	y1 = neighbor.clipped_ceilings1[render->nv1] - env->player.head_z;
render_maths.c:	y2 = neighbor.clipped_ceilings2[render->nv2] - env->player.head_z;
render_maths.c:	render->scale1 = env->camera.scale / -render->clipped_vz1;
render_maths.c:	render->scale2 = env->camera.scale / -render->clipped_vz2;
render_maths.c:	render->floor1 = env->h_h +
render_maths.c:	render->floor2 = env->h_h +
render_maths.c:	render->ceiling1 = env->h_h +
render_maths.c:	render->ceiling2 = env->h_h +
render_maths.c:	render->horizon = env->h_h -
render_maths.c:		env->player.angle_z * env->camera.scale;
render_maths.c:	render->floor_horizon = env->h_h
render_maths.c:		+ (sector.floor_slope * (sector.floor_max + env->player.head_z) + render->preclip_angle_z1) * env->camera.scale / -render->vz1;
render_maths.c:	render->floor_horizon1 = env->h_h
render_maths.c:		+ (sector.floor_slope * (sector.floors[i] - env->player.head_z) + render->preclip_angle_z1) * env->camera.scale / -render->vz1;
render_maths.c:	render->floor_horizon2 = env->h_h
render_maths.c:		+ (sector.floor_slope * (sector.floors[i + 1] - env->player.head_z) + render->preclip_angle_z2) * env->camera.scale / -render->vz2;
render_maths.c:	render->ceiling_horizon = env->h_h
render_maths.c:		+ (sector.ceiling_slope * (sector.ceiling_max + env->player.head_z) + render->angle_z1) * render->scale1;
render_maths.c:	render->x1 = env->h_w + render->clipped_vx1 * render->scale1;
render_maths.c:	render->x2 = env->h_w + render->clipped_vx2 * render->scale2;
render_maths.c:	render->neighbor_floor1 = env->h_h +
render_maths.c:	render->neighbor_floor2 = env->h_h +
render_maths.c:	render->neighbor_ceiling1 = env->h_h +
render_maths.c:	render->neighbor_ceiling2 = env->h_h +
render_maths.c:	render->scale1 = env->camera.scale / -render->vz1;
render_maths.c:	render->scale2 = env->camera.scale / -render->vz2;
render_maths.c:	render->preclip_floor1 = env->h_h +
render_maths.c:	render->preclip_floor2 = env->h_h +
render_maths.c:	render->preclip_ceiling1 = env->h_h +
render_maths.c:	render->preclip_ceiling2 = env->h_h +
render_maths.c:	render->preclip_x1 = env->h_w + render->vx1 * render->scale1;
render_maths.c:	render->preclip_x2 = env->h_w + render->vx2 * render->scale2;
render_maths.c:			, env->ymin[x], env->ymax[x]);
render_maths.c:			, env->ymin[x], env->ymax[x]);
screen_utils.c:	if (SDL_UpdateTexture(env->sdl.texture, NULL, env->sdl.texture_pixels, env->w * sizeof(Uint32)))
screen_utils.c:	SDL_RenderCopy(env->sdl.renderer, env->sdl.texture, NULL, NULL);
screen_utils.c:	SDL_RenderPresent(env->sdl.renderer);
screen_utils.c:	max = env->w * env->h;
screen_utils.c:		if (env->depth_array[i] > max_z)
screen_utils.c:			max_z = env->depth_array[i];
screen_utils.c:		if (env->depth_array[i] < min_z)
screen_utils.c:			min_z = env->depth_array[i];
screen_utils.c:	while (y < env->h)
screen_utils.c:		while (x < env->w)
screen_utils.c:			if ((y <= 300 && x < env->w - 300) || y > 300 || env->editor.in_game || !env->options.show_minimap)
screen_utils.c:				alpha = 1 - env->depth_array[x + env->w * y] / max_z;
screen_utils.c:				if (env->depth_array[x + env->w * y] >= 0 && alpha >= 0 && alpha <= 1)
screen_utils.c:					env->sdl.texture_pixels[x + env->w * y] = (int)(alpha * 0xFF) << 24
screen_utils.c:				else if (env->depth_array[x + env->w * y] == 100000000)
screen_utils.c:					env->sdl.texture_pixels[x + env->w * y] = 0xFFAA0000;
screen_utils.c:					env->sdl.texture_pixels[x + env->w * y] = 0;
screen_utils.c:	if (SDL_UpdateTexture(env->sdl.texture, NULL, env->sdl.texture_pixels, env->w * sizeof(Uint32)))
screen_utils.c:	SDL_RenderCopy(env->sdl.renderer, env->sdl.texture, NULL, NULL);
screen_utils.c:	SDL_RenderPresent(env->sdl.renderer);
screen_utils.c:	texture_pixels = env->sdl.texture_pixels;
screen_utils.c:					&& pos.y + x >= 0 && pos.y + x < env->w && pos.x + y >= 0 && pos.x + y < env->h)
screen_utils.c:			texture_pixels[pos.y + x + env->w * (pos.x + y)] =
screen_utils.c:	pixels = env->sdl.texture_pixels;
screen_utils.c:	max = env->h;
screen_utils.c:		pixels[i * env->w + env->h_w] = 0xFFFFFFFF;
screen_utils.c:	max = env->w;
screen_utils.c:		pixels[env->h_h * env->w + i] = 0xFFFFFFFF;
screen_utils.c:	pixels = env->sdl.texture_pixels;
screen_utils.c:	x = env->h_w;
screen_utils.c:	y = env->h_h - 10;
screen_utils.c:	max = env->h_h - 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
screen_utils.c:	y = env->h_h + 10;
screen_utils.c:	max = env->h_h + 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
screen_utils.c:	y = env->h_h;
screen_utils.c:	x = env->h_w - 10;
screen_utils.c:	max = env->h_w - 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
screen_utils.c:	x = env->h_w + 10;
screen_utils.c:	max = env->h_w + 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
sprites_maths.c:		get_translated_object_pos(env, &env->objects[i]);
sprites_maths.c:		get_rotated_object_pos(env, &env->objects[i]);
sprites_maths.c:		- env->player.pos.x;
sprites_maths.c:	object->translated_left_bottom.z = object.pos.y - env->player.pos.y;
sprites_maths.c:	object->translated_left_bottom.y = (object.pos.z - env->player.pos.z);
sprites_maths.c:		- env->player.pos.x;
sprites_maths.c:		- env->player.pos.z;
sprites_maths.c:	object->translated_pos.x = object->pos.x - env->player.pos.x;
sprites_maths.c:	object->translated_pos.z = object->pos.y - env->player.pos.y;
sprites_maths.c:	object->translated_pos.y = object->pos.z - env->player.head_z;
sprites_maths.c:		* env->player.angle_sin - object->translated_left_bottom.z
sprites_maths.c:		* env->player.angle_cos;
sprites_maths.c:		* env->player.angle_cos + object->translated_left_bottom.z
sprites_maths.c:		* env->player.angle_sin;
sprites_maths.c:		+ object->rotated_left_bottom.z * env->player.angle_z;
sprites_maths.c:		* env->player.angle_sin - object->translated_right_bottom.z
sprites_maths.c:		* env->player.angle_cos;
sprites_maths.c:		+ object->rotated_left_bottom.z * env->player.angle_z;
sprites_maths.c:		* env->player.angle_sin - object->translated_pos.z * env->player.angle_cos;
sprites_maths.c:		* env->player.angle_cos + object->translated_pos.z * env->player.angle_sin;
sprites_maths.c:		+ object->rotated_pos.z * env->player.angle_z;
sprites_maths.c:	scale = env->camera.scale;
sprites_maths.c:	orender->screen_pos.y = env->h_h
sprites_maths.c:	orender->screen_pos.x = env->h_w + (object.rotated_pos.x * (scale / -object.rotated_pos.z));
sprites_maths.c:	orender->dist = sqrt(pow(object.pos.x - env->player.pos.x, 2)
sprites_maths.c:		+ pow(object.pos.y - env->player.pos.y, 2));
valid_map.c:	while (i < env->nb_sectors)
valid_map.c:	vertex = env->vertices[0];
valid_map.c:		vertex = env->vertices[sector.vertices[i]];
valid_map.c:	env->player.sector = get_sector_no_z(env, env->player.pos);
valid_map.c:	if (!env->nb_sectors)
valid_map.c:	if (!env->editor.new_player)
valid_map.c:	if (env->player.sector == -1)
valid_map.c:	while (i < env->nb_sectors)
valid_map.c:		if (check_sector(env->sectors[i], env))
valid_map.c:	while (i < env->nb_vertices)
vertices_selection.c:	while (i < env->nb_sectors)
vertices_selection.c:		while (j < env->sectors[i].nb_vertices)
vertices_selection.c:			if (env->editor.selected_vertex == env->sectors[i].vertices[j])
vertices_selection.c:				env->editor.reverted = get_clockwise_order_sector(env, i) ? 0 : 1;
vertices_selection.c:				revert_sector(&env->sectors[i], env);
vertices_selection.c:	if (!env->inputs.left_click && env->editor.selected_vertex != -1 && is_new_dragged_vertex_valid(env, env->editor.selected_vertex))
vertices_selection.c:			if (click_vertex != -1 && click_vertex != env->vertices[env->editor.selected_vertex].num)
vertices_selection.c:				env->vertices[env->editor.selected_vertex].x = env->editor.start_pos.x;
vertices_selection.c:				env->vertices[env->editor.selected_vertex].y = env->editor.start_pos.y;
vertices_selection.c:			env->vertices[env->editor.selected_vertex].x = round((env->sdl.mx - env->editor.center.x) / env->editor.scale);
vertices_selection.c:			env->vertices[env->editor.selected_vertex].y = round((env->sdl.my - env->editor.center.y) / env->editor.scale);
vertices_selection.c:		env->editor.selected_vertex = -1;
vertices_utils.c:	while (i < env->nb_sectors)
vertices_utils.c:		while (j < env->sectors[i].nb_vertices)
vertices_utils.c:			if (env->sectors[i].vertices[j] == index)
vertices_utils.c:	while (i < env->nb_sectors)
vertices_utils.c:			while (j < env->sectors[i].nb_vertices)
vertices_utils.c:				if (env->sectors[i].vertices[j] == vertex)
vertices_utils.c:	while (i < env->nb_sectors)
vertices_utils.c:		while (j < env->sectors[i].nb_vertices)
vertices_utils.c:			if (env->sectors[i].vertices[j] == vertex)
vertices_utils.c:	tmp = env->editor.current_vertices;
view.c:	angle = env->player.angle;
view.c:	angle_cos = env->player.angle_cos;
view.c:	angle_sin = env->player.angle_sin;
view.c:	env->player.angle += env->sdl.mouse_x * env->player.rotation_speed;
view.c:	env->player.angle_cos = cos(env->player.angle);
view.c:	env->player.angle_sin = sin(env->player.angle);
view.c:	env->player.perp_cos = cos(env->player.angle - M_PI / 2);
view.c:	env->player.perp_sin = sin(env->player.angle - M_PI / 2);
view.c:	env->player.angle_z = ft_fclamp(env->player.angle_z + env->sdl.mouse_y * 0.005, -5, 5);
view.c:	env->player.angle_z_cos = cos(env->player.angle_z);
view.c:	env->player.angle_z_sin = sin(env->player.angle_z);
weapons.c:	pixels = env->sdl.texture_pixels;
weapons.c:	texture_pixels = env->textures[sprite].str;
weapons.c:	texture_w = env->textures[sprite].surface->w;
weapons.c:	texture_h = env->textures[sprite].surface->h;
weapons.c:    window_w = (int)(env->w - texture_w) / 1.5;
weapons.c:    window_h = (env->h - texture_h) + env->weapons[0].weapon_switch;
weapons.c:        while (y < texture_h  && (window_h + y) < env->h)
weapons.c:                pixels[(window_w + x) + env->w * (window_h + y)] = 
weapons.c:    if (env->shot.start == 0)
weapons.c:        env->shot.on_going = 1;
weapons.c:		env->shot.start = SDL_GetTicks();
weapons.c:        if (env->weapons[nb].ammo <= 0)
weapons.c:            env->weapons[nb].no_ammo = 1;
weapons.c:			Mix_PlayChannel(2, env->weapons[nb].empty, 0);
weapons.c:            env->weapons[nb].no_ammo = 0;
weapons.c:            Mix_PlayChannel(2, env->weapons[nb].sound, 0);
weapons.c:            env->weapons[nb].ammo--;
weapons.c:    if (!env->weapons[nb].no_ammo)
weapons.c:        if (env->time.milli_s > env->shot.start + 70 && ((env->time.milli_s - env->shot.start) / 70 < env->weapons[nb].nb_sprites))
weapons.c:            draw_weapon(env, env->weapons[nb].first_sprite + (int)((env->time.milli_s - env->shot.start) / 70));
weapons.c:            draw_weapon(env, env->weapons[nb].first_sprite);
weapons.c:        draw_weapon(env, env->weapons[nb].first_sprite);
weapons.c:    if ((int)((env->time.milli_s - env->shot.start)) >= env->weapons[nb].nb_sprites * 70)
weapons.c:        env->shot.start = 0;
weapons.c:        env->shot.on_going = 0;
weapons.c:    if (env->weapon_change.start == 0)
weapons.c:        env->weapon_change.start = SDL_GetTicks();
weapons.c:        env->weapon_change.on_going = 1;
weapons.c:    time_spent = env->time.milli_s - env->weapon_change.start;
weapons.c:        env->weapons[0].weapon_switch  = 75 * (int)(time_spent / 70);
weapons.c:        if (env->sdl.event.wheel.y > 0)
weapons.c:		    env->player.curr_weapon = (env->player.curr_weapon >= NB_WEAPONS - 1 ? 0 : env->player.curr_weapon + 1);
weapons.c:	    else if (env->sdl.event.wheel.y < 0)
weapons.c:	        env->player.curr_weapon = (env->player.curr_weapon <= 0 ? NB_WEAPONS - 1 : env->player.curr_weapon - 1);
weapons.c:        env->weapons[0].weapon_switch = 0;
weapons.c:        env->weapon_change.start = 0;
weapons.c:        env->weapon_change.on_going = 0;
weapons.c:    str = ft_sitoa(env->weapons[env->player.curr_weapon].ammo);
weapons.c:    print_text(new_point(env->h - env->h / 12, env->w - env->w / 14 - 5), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
weapons.c:    print_text(new_point(env->h - env->h / 12, env->w - env->w / 19), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
weapons.c:    str = ft_sitoa(env->weapons[env->player.curr_weapon].max_ammo);
weapons.c:    print_text(new_point(env->h - env->h / 12, env->w - env->w / 24), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
write_objects.c:	ft_dprintf(fd, "\nO %d\n", env->nb_objects);
write_objects.c:	while (i < env->nb_objects)
write_objects.c:		write_object(fd, env->objects[i]);
write_player.c:			env->player.pos.y, env->player.pos.x,
write_player.c:			(int)(env->player.angle * CONVERT_DEGREES) % 360,
write_player.c:			env->player.sector);
write_sectors.c:	ft_dprintf(fd, "\nS %d\n", env->nb_sectors);
write_sectors.c:	while (i < env->nb_sectors)
write_sectors.c:		write_sector(fd, env->sectors[i]);
write_vertices.c:	ft_dprintf(fd, "V %d\n", env->nb_vertices);
write_vertices.c:	while (i < env->nb_vertices)
write_vertices.c:		size = ft_max(ft_getsize(env->vertices[i].y), ft_getsize(env->vertices[i].x));
write_vertices.c:	while (i < env->nb_vertices)
write_vertices.c:		ft_dprintf(fd, "%-*.5f %.5f\n", padding, env->vertices[i].y, env->vertices[i].x);
